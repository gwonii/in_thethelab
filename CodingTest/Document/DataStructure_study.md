## DataStructure



### 1.  stack

* first in last out

header : <stack>

| 명령어 | 설명                                      |
| ------ | ----------------------------------------- |
| push   | 스택에 데이터를 넣는다.                   |
| pop    | 스택에서 가장 위에 있는 데이터를 뺀다.    |
| size   | 스택에 들어있는 데이터의 개수를 나타낸다. |
| empty  | 스택이 비어있는지 아닌지 확인한다.        |
| top    | 스택에 가장 위에 있는 데이터를 보여준다.  |

> stack api를 사용하지 않고 직접 코딩할 줄 알아야 한다.

### 2. queue 

* first in first out

header : <queue>

| 명령어 | 설명                                              |
| ------ | ------------------------------------------------- |
| push   | 큐에 데이터를 넣는다.                             |
| pop    | 큐에 상대적으로 가장 먼저 넣은 데이터를 뺀다.     |
| size   | 큐에 들어있는 데이터의 개수를 나타낸다.           |
| empty  | 큐가 비어있는지 아닌지 확인한다.                  |
| front  | 큐에 상대적으로 가장 먼저 넣은 데이터를 보여준다. |

> stack 과 맟찬가지 

### 3. tree

#### 3.1 개념 

* 트리는 하나의 루트 노드를 갖는다. 

* 루트 노드는 0개 이상의 자식 노드를 갖는다. 

* 그 자식 노드 또한 0개 이상의 자식 노드를 갖고 있고, 이는 반복적으로 정의된다. 

* 노드들은 간선들로 구성되어 있다. 
  * 트리에는 사이클이 존재할 수 없다. 
  * 노드들은 특정 순서로 나열될 수도 있고 아닐 수도 있다. 
  * 각 노드는 부모 노드로의 연결이 있을 수도 있고 없을 수도 있다. 

* 각 노드는 어떤 자료형으로도 표현이 가능하다. 

* 비선형 자료구조로 계층적 관계를 표현한다. 

#### 3.2 트리 관련 용어 

```
루트 노드(root node): 부모가 없는 노드, 트리는 하나의 루트 노드만을 가진다.
단말 노드(leaf node): 자식이 없는 노드, ‘말단 노드’ 또는 ‘잎 노드’라고도 부른다.
내부(internal) 노드: 단말 노드가 아닌 노드
간선(edge): 노드를 연결하는 선 (link, branch 라고도 부름)
형제(sibling): 같은 부모를 가지는 노드
노드의 크기(size): 자신을 포함한 모든 자손 노드의 개수
노드의 깊이(depth): 루트에서 어떤 노드에 도달하기 위해 거쳐야 하는 간선의 수
노드의 레벨(level): 트리의 특정 깊이를 가지는 노드의 집합
노드의 차수(degree): 하위 트리 개수 / 간선 수 (degree) = 각 노드가 지닌 가지의 수
트리의 차수(degree of tree): 트리의 최대 차수
트리의 높이(height): 루트 노드에서 가장 깊숙히 있는 노드의 깊이
```

#### 3.3 트리의 특징 

* 그래프의 한 종류이다. **최소 연결 트리** 라고도 불린다. 
* 트리는 **계층모델**이다. 
* 트리는 **사이클**(순환)이 없다.
* 노드가 N개인 트리는 항상 N-1개의 간선을 가진다. 
* 루트에서 임의의 노드로 가는 경로는 유일하다. 
* 한 개의 루트 노드만이 존재하며 모든 자식 노드는 한 개의 부모 노드만을 가진다. 
* 순회는 pre - order, in - order , post - order로 이루어진다. 이 세가지는 DFS / BFS 안에 있다. 

#### 3.4 트리의 종류 

1. 이진 트리
2. 이진 탐색 트리
3. 균형 트리 (AVL 트리, Red-Black 트리), 이진 힙(최대 힙, 최소 힙)  등이 있다. 

##### 3.4.1 Binary Tree 

* 각 노드가 최대 두개의 자식을 갖는 트리
* 모든 트리가 이진 트리는 아니다. 

**이진 트리 순회** 

1. 중위 순회 (in-order) : 왼쪽 가지 -> 현재 노드 -> 오른쪽 가지
2. 전위 순회 (pre-order) : 현재 노드 -> 왼쪽 가지 -> 오른쪽 가지 
3. 후위 순회 (post-order) : 왼쪽 가지 -> 오른쪽 가지 -> 현재 노드 

##### 3.4.2 Binary Search Tree

* 모든 노드가 아래와 같은 특정 순서를 따르는 속성이 있는 이진 트리 
* 노드의 값이 모든 왼쪽 자식들 <= n (node) < 모든 오른쪽 자식들 (모든 노드 n에 대해 참)

**완전 이진 트리** : 트리의 모든 높이에서 노드가 꽉차 있는 이진 트리, 즉 마지막 레벨을 제외하고 모든 레벨이 완전히 채워져 있다. (마지막 레벨이 비워져 있다면 왼쪽부터 다 채워져 있어야 완전 이진 트리)

**전 이진 트리** : 모든 노드가 0개 또는 2개의 자식을 갖는 트리 

**포화 이진 트리** : 전 이진 트리이면서 완전 이진 트리인 경우, 모든 내부 노드가 두 개의 자식 노드를 ㅏ가진다. 

##### 3.4.3 Binary Heap 

* **최소 힙** : 트리의 마지막 단계에서 오른쪽 부분을 뺀 나머지 부분이 가득 채워져 있는 완전 이진트리이며, 각 노드의 원소가 자식들의 원소보다 작다. ( key (부모 노드) >= key (자식 노드) 이며 가장 큰 값은 루트 노드 )
* **최대 힙** : 원소가 내림차순으로 정렬되어 있다는 점에서만 최소힙과 다르다. 

##### 3.4.4 trie ( prefix - tree)

* n-차 트리의 변종 
* 각 노드에 문자를 저장하는 자료구조 
* 트리를 아래쪽으로 순회하면 단어하나가 나온다. 
* 접두사를 빠르게 찾아보기 위한 흔한 방식, 모든 언어를 트라이에 저장해 놓는 방식이 있다. 
* 유효한 단어 집합을 이용하는 많은 문제들은 트라이를 통해 최적화할 수 있다. 

#### 3.5 구현 방법 

##### 3.5.1 인접 배열 이용 

* 1차원 배열에 자신의 부모 노드만 저장하는 방법 

##### 3.5.2 인접 리스트 이용 

* 가중치가 없는 경우 : `ArrayList<ArrayList> list = new ArrayList<>()`
* 가중치가 있는 경우 : class Node {int num, dist; // 노드 번호, 거리 } 정의 ArrayList[] list = new ArrayList[정점의 수 + 1];



 

