### 5장 자료형과 변수 그리고 상수의 표현

#### 5.1 c언어의 기본 자료형 : 정수형으로
---

* **자료형을 나누는 기준**

1. 표현할 데이터의 종류
2. 바이트 크기

**정수 자료형에는**

    1) char : 최소 8비트 이상
    2) short : 최소 16비트 이상
    3) int : 최소 16비트 이상  // 데이터 크기는 32비트
    4) long : 최소 32비트 이상
    5) long long : 최소 64비트 이상

>char은 -128 ~ 127까지 표현한다.
      short은 -32,768 ~ 32,767까지 표현한다.
      int는 -2,147,483,648 ~ 2,147,483,647까지 표현한다.
      long은 엄청 많이 표현한다.
      long long 더 많이 표현한다.

* 모든 정수 자료형 뒤에는 int가 생략되어 있다.

      ex) char int, short int, long int .....


* 언더플로우 : 특정 자료형에 저장되는 데이터 양이 -로 초과했을 경우


**unsigned 자료형**

      unsigned char : 8비트 0 ~ 255
      unsigned short : 16비트 0 ~ 65,535
      unsigned int : 32비트 0 ~ 4,294,967,295
      unsigned long : 32비트 엄청 많음
      unsigned long long : 64비트 더 많음

>정수 자료형에 양수만을 표현해주는 unsigned
실수 자료형에는 사용할 수 없다.


#### 5.2 c언어의 기본 자료형 : 실수형
---
* **실수 자료형에는**

| 자료형     | 값의 표현범위     | 소수점이하 정밀도     |
| :------------- | :------------- | :------------- |
| float     | 10^(-37) ~ 10^(37) 까지      | 6자리 이상    |
| double      |float 이상의 범위      | 10자리 이상    |
| long double     |double 이상의 범위     |double이상의 정밀도     |
> float 4바이트
double 8바이트
long double 12바이트

#### 5.3 적절한 자료형의 선택기준 : 정수 자료형 기준
---
* **cpu의 연산 시스템 (정수의 승격)**

보통 cpu는 같은 자료형 끼리의 연산이 가능하도록 설계되어 있다. 하지만 같은 자료형이 아님에도 불구하고 계산을 해야 되는 경우가 생긴다. 그런 경우 cpu는 정수의 승격 (integer promotion)을 통해 계산이 될 수 있도록 형변환을 시킨다.


      ex)
      int 와 char의 연산을 해야된다면 cpu는 자연스럽게 char를 int로
      형변환 시켜 둘의 연산을 가능케 한다. 이러한 이유는
      데이터의 손실을 덜기 위하여 큰 범위를 표현하는 자료형에 맞춘다.

>보통 int로 변환되어 연산되는 이유는 컴퓨터가 32비트 cpu를 대중적으로 사용하고 있어서 32비트 짜리 int가 가장 계산 속도가 빠르다. 그렇기 때문에 int를 기본형으로 사용하고 있는 것이다.

* **그러면 보통 메모리의 효율을 우선시 할까? 연산속도를 우선시 할까?**

때에 따라 다르게 나타난다. 보통은 연산 속도를 우선시 하는게 맞긴 하지만 데이터의 양을 중요하게 생각해야 되는 부분도 존재한다. 그래서 사전에 int 보다 데이터 양이 적은 자료형들은 int로 변환을 시킨 후에 연산을 시키는 것이 효율적이다.

* **unsigned 자료형의 예외상황**

unsigned 되어 있는 자료형의 경우에는 예외현상이 발생한다. 보통 연산을 위해 int로 정수의 승격을 시켜주는 것이 일반적이지만, unsigned 같은 경우 음수를 표현하지 않기 때문에 음수까지 표현되는 int로 바로 형변환 시키는데, 문제가 생길 수 있다. 그렇기에 unsigned의 경우에는 int에도 unsigned int를 사용하여 승격의 문제를 해결한다. 결국 unsigned int 또는 int로 형변환된다고 생각하면 된다.


#### 5.4 적절한 자료형의 선택 기준 : 실수 자료형 기준
---
* **실수 자료형의 선택**

보통 실수 자료형을 선택할 때 float 또는 double 사이에서 고민을 한다. long double 같은 경우 12바이트라는 큰 단위의 메모리를 차지한다. 높은 정밀도를 가지고 있기 때문에 이점은 있지만 보통의 경우에 12바이트 처럼 높은 정밀도를 필요로 하는 상황이 적다 . 그렇기에 float과 double사이에서 자료형을 고민한다.

>정수 자료형은 표현범위가 우선시 되어야 한다. 하지만 실수 자료형 같은 경우 반드시 오차가 생기기 때문에 표현범위 보다 정밀도를 중요하게 생각해야 한다.


#### 5.5 변수의 선언방식과 조건
---
* **변수의 선언**

변수는 선언(declaration) 한다고 표현한다.

* **변수의 다양한 선언 방법**

      case1:
          int val;
          val = 20;

      case2:
          int val = 20;

      case3:
          int val1;
          int val2;

          val1 = 10;
          val2 = 20;

      case4:
          int val1;
          val1 = 10;

          int val2;
          val2 = 20;

      case5:
          int val1 = 10 , val2 = 20;
> 변수의 선언이 블록 안에 올 때에는 반드시 블록의 머리부분에 등장해야 한다.


* **변수 이름의 조건**

1. 변수의 이름은 알파벳, 숫자, 언더바를 조합해서 만들 수 있다.
2. 변수의 이름은 대소문자가 구분된다.
3. 변수의 이름은 숫자로 시작할 수 없고, c언어 문법을 구성하는, 의미를 지니는 키워드는 사용 불가능하다.
4. 변수의 이름에는 공백이 포함될 수 없다.

>변수의 이름을 정할 때에는 반드시 의미있는 이름을 붙이도록 노력해야  한다.


#### 5.6 변수의 상대적 개념 상수
---
**상수(constant) : 변경 불가능한 수**


cpu의 연산을 위해 수를 메모리에 저장시킬 때에도 컴퓨터는 상수로 값들을 저장시켜 놓는다.

    ex)
    x = 5 + 8; 이라는 코드가 있다고 할 때 메인 메모리에 5와 8이라는
    상수를 저장시켜 놓고 cpu로 연산을 진행한다.

* **상수를 저장시킬 때 결정해야 하는 세 가지**

1. 정수형으로 저장할 것인가? 실수형으로 저장할 것인가?
2. 음수를 표현할 것인가?
3. 몇 바이트로 표현할 것인가?

>이것은 다시 말해 저장할 때 어떤 자료형을 선택할 것인가? 라는 물음과 같다.


* **보통 정수형 상수는 int형으로 , 실수형 상수는 double형으로 저장된다.**

      int n;
      double d;

      n = 1 + 2;
      d = 1.1 + 2.2;



>라고 할 때 n과 d가 각각 int형, double형 이기 때문에 상수가 그
        자료형으로 저장된다고 생각할 수 있지만 기본적으로 상수는 int로
        실수는 double로 저장된다.
        다시 말해 대입 연산자의 왼쪽에 있는 변수의 자료형에 따라서 상수의
        자료형이 결정되는 것이 아니고, 상수는 각각 int형과 double형으로
        저장된다는 사실!


* **접미사를 이용하여 상수의 자료형 변경하기**


      float f1 = 3.14;
      float f2 = 1.24 + 2.56;

>위의 예시는 에러가 발생한다.상수는 double로 저장되어 있는데 변수의 자료형이 float이기 때문이다. 자세히 얘기하면 double형을 float형으로 바꾸기 때문에 데이터가 잘려나갈수 있는 문제가 발생할 수 있다.

**변경 후**

      float f1 = 3.14f;
      float f2 = 1.24f + 2.56f;


* **리터럴 상수와 심볼릭 상수**

| 상수 이름     | 상수의 영어 이름     |의미     |
| :------------- | :------------- |:------------- |
| 리터럴 상수       | literal constant      |이름을 갖지 않는 상수    |
| 심볼릭 상수       | symbolic constant    |이름을 갖고 있는 상수     |

      int num = 10;

>여기서 10은 상수다. 하지만 num은 변수다. 여기서 num이 변하지 않게 조정할 수 있다면 num도 상수가 될 수 있다. 여기서 10은 리터럴 상수이고, num은 심볼릭 상수라고 할 수 있다.

* **const 상수**

      const int MAX_LEN = 333;
이런 식으로 의도적으로 변수를 상수처럼 만들 수 있다.
이렇게 const를 사용할 때는 변수의 이름을 대문자로 사용한다.


#### 5.7 접미사에 따른 상수의 자료형
---

* **정수형**

| 접미사     | 자료형     |
| :------------- | :------------- |
|U       |  unsigned int      |
| L       | long     |
| UL       |unsigned long      |
| LL       | long long      |
| ULL       |unsigned long long |
<BR>


* **실수형**

| 접미사 | 자료형     |
| :------------- | :------------- |
| F       | float       |
| L       | long double       |

>겹치는 L의 경우 정수에 사용하면 long, 실수에 사용하면 long double가 된다.

<br>

**int와 double이 없는 이유는 상수의 기본 저장 자료형이 int와 double이기 때문**
