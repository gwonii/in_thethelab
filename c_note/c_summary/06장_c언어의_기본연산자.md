## 6장 c언어의 기본 연산자

### 6.1 산술 연산자를 통해서 보는 연산의 원리
---

* 연산자 (operator)

cpu에서 연산을 시키기 위해서 사용되는 것들이 연산자 (operator)라고 한다.

| 연산자 | 연산자 기능     | 결합방향     |
| :------------- | :------------- |:------------- |
| =       | 연산자 오른쪽에 있는 값을 왼쪽에 있는 변수에 대입한다.|<--       |
| +       | 두 연산자의 값을 더한다       |-->       |
| -       | 왼쪽의 피연산자 값에서 오른쪽의 피연사자 값을 뺀다       |-->       |
| *       | 두 피연산자의 값을 곱한다.       |-->       |
| /      | 왼쪽의 피연산자 값을 오른쪽 피연산자 값으로 나눈다. |-->       |
| %       | 왼쪽의 피연산자 값을 오른쪽의 피연산자 값으로 나눴을 때 얻게 되는 나머지   |-->       |

* printf문에 연산의 있는 경우 연산을 진행한 후에 출력한다.

      printf ("hello %d \n", n1 * n2);

> 가 있다면 위의 코드는 n1 * n2를 진행한 후에 그 값을 %d에 넣고 printf 명령을 진행한다.

보통 연산할 때 두 피연산자의 자료형이 같아야 한다. 그래야 연산 속도가 빨라진다. 하지만 두 피연산자의 자료형이 다를 경우 산술 변환이 일어난다. 기존 전략은 데이터의 손실을 최소화 하는 방향, 즉 피연산자의 자료형이 다를 경우 데이터 표현범위가 큰 자료형을 따른다.

* % 연산자의 경우 피연산자는 반드시 정수여야 한다.

### 6.2 연산자들의 우선순위와 결합방향

* 연산의 우선순위와

연산자내에서도 우선순위가 존재한다. 연산을 할 때에는 cpu가 우선순위에 따라 연산을 한다.
만약 우선순위가 같다면 결합방향에 따라 연산이 진행된다.

| 순위     | 연산기호     | 연산자     | 결합방향     |
| :------------- | :------------- |:------------- |:------------- |
| 1위       | ()       |함수 호출       |-->       |
| 1위       | []       |인덱스       |-->       |
| 1위       |->       |간접지정       |-->       |
| 1위       | .       |직접지정       |-->       |
| 1위       |++(postfix)       |후위증가       |-->       |
| 1위       |--(postfix)       |후위감소       |-->       |
| 2위       |++(prefix)       |전위증가       |<--       |
| 2위       |--(prefix)       |전위감소       |<--       |
| 2위       |sizeof       |바이트 크기 계산       |<--       |
| 2위       |~       |비트단위 NOT       |<--       |
| 2위       |-,+       |부호연산(음수와 양수 표현)       |<--       |
| 2위       |&       |주소연산       |<--       |
| 2위       |*       |간접 지정 연산       |<--       |
| 3위       |(casting)       |자료형 변환       |<--       |
| 4위       |* , / , %       |곱셈, 나눗셈, 관련 연산       |-->       |
| 5위       |-, +       |덧셈, 뺄셈 관련 연산       |-->       |
| 6위       |<<, >>       |비트 이동       |-->       |
| 7위       |<, >, <=, >=       |대소 비교       |-->       |
| 8위       |==, !=       |동등 비교       |-->       |
| 9위       |&       |비트 AND       |-->       |
| 10위       |^       |비트 XOR       |-->       |
| 11위       |\       |비트 OR       |-->       |
| 12위       |&&       |논리 AND       |-->       |
| 13위       |\\\      |논리 OR       |-->       |
| 14위       |?:       |조건 연산       |<--       |
| 15위       |=, +=, -=, *=, /=, %=, <<=, >>=, &=, ^=, \\=       |대입 연산자       |-->      |
| 16위       |,       |콤마 연산       |-->       |

> 연산의 순서를 직접 지정할 때에는 () 소괄호를 사용한다.

### 6.3 다양한 연산자
---

* 복합 대입 연산자

| 변형 전 수식     |변형     |변형 후 수식     |
| :------------- | :------------- |:------------- |
| a=a+b       |-->       |a+=b       |
| a=a-b       |-->       |a-=b       |
| a=a*b       |-->       |a*=b       |
| a=a/b       |-->       |a/=b       |
| a=a%b       |-->       |a%=b       |

> 여기서 복합 대입 연산자는 한 개의 연산자로 취급한다. a += b 에서 +와 = 사이에 무언가 들어가면 오류가 발생한다.

* 부호 연산자 + , -

부호 연산자 + , -는 단항연산자 (unary operator) 라고 한다.
<br>
보통 - 연산자는 음수를 만들기 위해 사용되지만 + 연산자의 경우에는 변화는 없지만 값이 +라는 것을 강조하려고 할 때 사용된다.

* 증가, 감소 연산자 (++ , --) : prefix

| 연산자    | 연산자 기능     |결합방향     |
| :------------- | :------------- | :------------- |
| ++       |피연산자에 저장된 값을 1 증가       |<--       |
| --       |피연산자에 저장된 값을 1 감소       |<--       |

* 증가, 감소 연산자 (++ , --) : postfix

| 연산자     |연산자 기능     |결합방     |
| :------------- | :------------- |:------------- |
| ++       |피연산자에 저장된 값을 1 증가      |-->       |
| --       |피연산자에 저장된 값을 1 감소      |-->       |

      num1 = ++num;
      num2 = num++;
> num1의 경우 num의 값을 먼저 증가시킨 후에 num1에 대입시킨다.반면 num2의 경우 num의 값을 먼저 대입하고 라인이 끝난 후에 값을 증가시킨다.

* 관계 연산자 ( < , > , == , != , <= , >= )     

| 연산자     |연산자 기능     |결합방향     |
| :------------- | :------------- |:------------- |
| <       | n1 < n2 (n1이 n2보다 작은가?)      |-->       |                
| >      | n1 > n2 (n1이 n2보다 큰가?)       |-->       |
| ==       |  n1 == n2 (n1과 n2가 같은가?)      |-->       |
| !=       | n1 != n2 (n1과 n2가 다른가?)       |-->       |
| <=       | n1 <= n2 (n1이 n2보다 작거나 같은가?)       |-->       |
| >==       | n1 >= n2 (n1이 n2보다 크거나 같은가?)      |-->       |

> 계연산자의 연산결과는 참 (1) , 거짓 (0)의 값을 반환한다.c에서는 '0'을 거짓 '0 이외의 숫자'를 참 으로 정의한다.

* 논리 연산자 ( && , || , !)

| 연산자     |연산자 기능     |결합방향     |
| :------------- | :------------- | :------------- |
| &&       | A && B (A와 B 모두 참이면 참, AND)       |-->      |
| \\       |A || B (A와 B 둘 중 하나라도 참이면 참, OR )       |-->       |
| !       | !A (연산결과는 A가 참이면 거짓, 거짓이면 참, NOT )        |-->       |

* 논리 연산자와 SCE(short-circuit evaluation)

가장 빠르게 값을 계산하는 연산
<br>
논리 연산자 &&와 ||을 사용할 때 계산을 빠르게 할 수 있는 상황이 생긴다. &&의 경우 A && B , A가 틀린 경우 B의 참 거짓 유무를 확인할 필요가 없다. 컴퓨터도 이것을 받아들여 A && B 연산 중에 A가 거짓이라면 B연산을 진행하지 않고 연산을 끝낸다. 이렇게 빠른 계산을 가능하게 하는 것이 SCE이다. 마찬가지로 A || B의 경우 A가 참이라면 B의 연산을 진행하지 않고 연산을 끝낸다.

* 콤마 "," 연산자

둘 이상의 변수를 동시에 선언하거나, 둘 이상의 함수 호출문 또는 연산문을 하나의 문장으로 표현하는 경우 사용된다.

### 6.4 자료형 변환 연산자, sizeof 연산자
---

* 자료 변환 연산자 (cast operator)

자료 변환 연산자는 변수 앞에 자료형을 임의로 넣어 변수의 자료형을 변화시키는 것이다.

      printf (" 정수 출력 : %f \n", (double)3);
> int형 3을 임의로 double로 형변환 시켜 출력하라는 의미를 갖고 있다.

      int n1 = 3;
      double n2 = (double)n1;
> 의 경우 n1의 값이 double형으로 변환되는 것이 아니라, n1의 값을 참조하여 double형으로 새로운 값을 만들어 낼 뿐이다.

      int n1 = 3;
      double n2 = (double)n1;이
      doubl2 n2 = 3.0; 이 된 후에 대입시키는 것이다.

*  sizeof 연산자

sizeof 연산자는 피연산자의 크기를 바이트 단위로 계산해서 반환하는 연산자

### 연산의 결과가 남기는 것은?
---

* lvalue와 rvalue

lvalue는 left value를 줄임말이다. rvalue도 마찬가지. 대입 연산자 왼편에 오는 대상을 가리켜 lvalue라고 한다. 즉 대입이 가능한 피연산자를 의미한다. 대표적인 피연산자는 변수!

> 보통 모든 변수는 lvalue 이지만 모든 lvalue가 변수는 아니다!

* 대입 연산자의 반환

보통 대입 연산자가 대입만 한다고 생각하는데, 그렇지 않다. 대입연산자도 대입후에 값을 반환한다.

      num1 = num2 = num3;
> 만약 대입 연산자의 반환값이 없다면 위의 식은 연산되지 않을 것이다.

      num1 = (num2 = num3);
      num1 = ?
> 하지만 그렇지 않고 연산이 진행된다. 결국 대입 연산자도 값을 반환한다는 것을 알 수 있다.

### 6.6 자동으로 자료형이 변화되는 경우

* 산술 변환에 의한 자동 형변환

1. 정수형보다 실수형을 우선시한다.
2. 바이트 수가 작은 것보다 큰 것을 우선시한다.
3. unsigned를 우선시한다.
