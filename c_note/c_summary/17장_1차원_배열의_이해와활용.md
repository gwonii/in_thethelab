## 17장 1차원 배열의 이해와 활용

### 17.1 배열이라는 존재가 필요한 이유
---

코드를 작성하다보면 코드의 내용이 완전히 일치하지만 변수의 이름때문에
자동적으로 반복문을 사용할 수 없는 상황이 생긴다.
>이럴 때 문제를 해결해주는 것이 배열이다!

* 배열 선언에 필요한 세 가지

1. 변수의 이름
2. 변수의 자료형
3. 변수의 개수

      자료형 배열이름 개수
       int   array   [5]

> 주의점 위 처럼 배열의 각 요소들에 접근 할 때는 array[1]이 아니라 array[0]부터 시작한다.

> 보통 배열에서 반복문을 사용하고 싶을 때 반복문 종료조건에 sizeof()문이 자주 사용된다.

      5개의 요소를 가지고 있는 배열이라고 가정했을 때 5개 모두
      접근할 수 있도록 반복문을 만든다면 배열이 길이 만큼 반복문을
      진행해야 한다. 그럴 때 길이를 반복문 종료조건에 넣어야 하므로
      그 때 sizeof() 연산자를 자주쓰게 된다.

* 배열 요소에 접근할 때 사용하게 되는 정보는

1. 배열의 이름
2. 배열의 인덱스 정보

그리고 이 배열의 이름과 인덱스 정보를 통해 배열의 요소 주소값에 접근할 수 있다.

      int arr[3]
      ㅁㅁㅁㅁㅁ / ㅁㅁㅁㅁㅁ / ㅁㅁㅁㅁ

      위 처럼 int형 배열이 있다고 하면

      arr의 요소들에 대한 주소는 이렇다.

      arr[0]의 주소값을 0x10이라고 가정하자  

        arr[0] -> (arr) + 0*4 = 0x10 + 0
        arr[1] -> (arr) + 1*4 = 0x10 + 4
        arr[2] -> (arr) + 2*4 = 0x10 + 8

> 이렇게 int형의 바이트 값에 따라 요소들 마다 4의 주소값 차이를 보이는 것을 알 수 있다.

배열의 이름이 시작 주소를 알려준다. 인덱스 정보는 시작 주소 기준으로 몇 바이트를 이동해야 하는지 알려준다

위에 주소값 확인을 통해 두 가지 사실을 알 수 있게 되었다.

간혹  arr[-1] 의 주소값도 존재할 수 있다.
그저 arr[0]의 주소값에서 왼쪽으로 4바이트만큼 이동한 주소값이 된다.

* 배열의 이름의 대입

           int arr1[4] = {1,2,3,4};
           int arr2[4];

           arr2 = arr1;

> 의 코드를 사용하면 arr1의 값을 arr2에 복사될 것으로 예상한다. 하지만 위의 코드는 작동하지 않는다. 왜냐하면 배열의 이름은 배열의 첫 요소 주소값을 의미하기 때문이다.

      arr1의 주소값이 0x10, arr2의 주소값이 0x20이라고 하자

> 그러면 arr2 = arr1; 의 의미는 0x20 = 0x10 상수에 상수를 대입하는 꼴이 되버린다. 그렇기 때문에 문제를 일으킨다.
