###4장 데이터 표현방식의 이해
####4.1 진수와 진수 변환
---

* **2,8,10 그리고 16진수**
진수변환을 할 줄 알아야 한다.

>데이터는 저장되어 있는 형태에 따라서 그 종류가 결정되는 것이 아니고, 저장되어 있는 데이터를 어떻게 해석하느냐에 따라서 그 종류가 결정된다.

####4.2 데이터 표현의 단위
* **비트와 바이트**

컴퓨터가 나타내는 데이터의 최소 단위를 가리켜 비트라고 한다. 1비트는 2진수 값 하나를 저장할 수 있는 메모리 공간의 크기를 의미한다. 그리고 8비트 = 1바이트
<br>

* **시스템에서의 워드**

워드는 cpu가 한 번에 처리할 수 있는 데이터의 크기를 의미하는 단위이다. 보통 컴퓨터에서 자주 보는 32비트, 64비트가 워드의 대표적인 예이다. 따라서 1워드가 32비트, 64비트 라고 정의할 수 있다.

#### 4.3 정수의 표현방식의
---
* 정수를 표현하는데 있어서 가장 먼저 결정할 사항은 **"몇 바이트로 정수를 표현할 것인가?"** 이다.

정수는 1바이트, 2바이트, 8바이트로도 표현될 수 있다. 바이트의 크기가 클 수록 표현할 수 있는 정수의 범위가 커진다.

    ex) 보통 1바이트로 정수를 표현할 때 첫번째 1비트 공간은 부호를 담당하고
    나머지 7비트 공간은 데이터 크기를 나타낸다.

* **음수의 표현방법**

컴퓨터가 데이터를 가지고 있을 때 위에 말했듯이 첫번째 1비트 공간에 1 또는 0을 통해 부호 데이터를 저장하고 있지만 우리가 음의 정수를 표현할 때는

**"2의 보수"를 사용한다.**

> 2의 보수 계산법
    1바이트 로 표현된 정수 데이터에서 1의 보수 형태로 만든다

    ex) 00001011 정수 값 : 11

      여기서 1의 보수를 하면 11110100

      그리고 1의 보수에 1을 더하면 11110101

마지막에 나온 1바이트 데이터가 처음 00001011의 음수 값임을 알 수 있다.

####4.4 실수의 표현방식
---
* **표현의 범위와 정밀도**

실수는 보통 1과 2 사이에도 수 많은 수가 존재하기 때문에 표현의 어려움이 있다.

그래서 프로그래밍에서 선택한 방법은 정밀도를 포기하고, 표현의 범위를 넓히자는 방식이다. 보통 시스템 속에서는

    ex) 1.0과 (0.3 + 0.7)을 다른 데이터로 받아드리고 있다.

여기서 다시 "데이터는 저장되어 있는 형태에 따라서 그 종류가 결정되는 것이 아니고, 저장되어 있는 데이터를 어떻게 해석하느냐에 따라서 그 종류가 결정된다는 것을 확인할 수 있다."

####4.5 정수와 실수의 표현방식, 그리고 변수와의 관계
----
    ex)int num = 3;

int는 변수의 데이터 저장 및 참조방식에 대한 선언이다. int는 10진수 정수형으로 값을 저장 및 참조하라는 의미를 담고 있다.

이런 int와 같은 키워드를 가리켜 **자료형**(data type)이라고 한다.

> 정수를 표현하는데 사용되는 '정수 자료형'
  실수를 표현하는데 사용되는 '실수 자료형'

* %d와 %f

int는 저장된 값의 출력을 위해 %d를 서식문자로 사용하였는데 실수의 경우 %f의 서식문자를 사용한다.

>컴퓨터가 실수를 표현하는 방식은 아주 가까운 근사치를 표현하는 방식이다. 따라서 실수를 표현하는데 있어서 오차가 존재하는 것은 당연한 일이며, 이렇나 오차를 가리켜 **부동소수점** 오차라 한다. 이는 컴퓨터의 실수 표현방식이 부동소수점 방식이기 때문이다.

      예제 4.3.c

    #include <stdio.h>

    int main (void) {

      int i = 0;
      float real;

      real = 0;
      for (i=0,i<30,i++) {

        real = real + 0.1;
      }

      printf("0.1을 30회 더한 결과 : %f \n", real);

      real = 0;
      for (i=0,i<50,i++) {

        real = real + 0.1;
      }

      printf ("0.1을 50회 더한 결과 : %f \n", real);

      real = 0;
      for(i=0,i<100,i++) {

        real=real+0.1;

      }

      printf("0.1을 100회 더한 결과 : %f", real);

      return 0;

    }

>결과 값 :
0.1을 30회 더한 결과 : 2.999999
0.1을 50회 더한 결과 : 4.999998
0.1을 100회 더한 결과 : 10.000002

위에서 볼 수 있듯이 실수의 계산에서는 조금의 오차들이 존재한다.

* **부동소수점 오차가 존재하는 이유**

결국 왜 부동소수점 오차가 존재해야 하는지 알 필요가 있다. 컴퓨터는 표현의 범위를 넓히기 위해서 정밀도를 포기했다. 그렇기 때문에 부동소수점 오차가 생겨나는 것이다. 정밀도를 추구하다면, 정밀해지면 해질수록 표현할 수 있는 데이터의 양이 줄어든다.
