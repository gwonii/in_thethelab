## 15장 비트 연산자와 그의 활용

### 15.1 비트단위 연산자들의 종류와 기능
---
* 비트 연산자란?

비트연산자는 비트단위로 연산을 진행하는 연산자이다. 피연산자는 반드시 정수여야 한다. //실수에서 일어나는 비트연산은 의미가 없기 때문에 c에서는 지원하지 않는다.
<br>
비트 단위로 진행된 연산의 결과를 묶어서 최종적으로 하나의 연산결과를 반환한다.

      비트연산자와 비트쉬프트 연산자

        n1 : 01011001
        n2 : 11000011

        n1 & n2 : 0100001

        &연잔자의 경우 n1, n2 모두 1이면 1이 되는 AND의미의 연산자

| 연산자     |연산자의 기능     |결합방향     |
| :------------- | :------------- |:------------- |
| &       |비트단위로, AND연산을 한다       |-->       |
| \       | 비트단위로, OR연산을 한다       |-->       |
| ^       |비트단위로, XOR연산을 한다       |-->       |
| ~       | 단항연산자로서, 피연산장의 모든 비트를 반전시킨다       |-->        |
| <<       | 피연산자의 비트 열을 왼쪽으로 이동       |-->       |
| >>       | 피연산자의 비트 열을 오른쪽으로 이동       |-->       |

> 피연산자가 지니고 있는 값이 변경되는 것은 아니다.

> 연산결과는 참 또는 거짓이 아니다. 비트단위로 연산된 연산결과를 묶어서 최종적으로 하나의 연산결과를 반환한다.

* ~연산자

1. '~' 연산자는 가장 왼쪽에 있는 부호비트도 반전시킨다.
2. '~' 연산자는 피연산자가 음수일 때는 양수 또는 0을 반환한다.

* 비트 쉬프트 연산자

      int c = A<<B;

> A의 비트 열을 B크기 만큼 왼쪽으로 이동시켜라. 그리고 이동된 값을 변수 c에 대입시켜라.

      int n=1;
      int r1 = n<<1;
      int r2 = n<<2;
      int r3 = n<<3;
      int r4 = n<<4;

      printf("r1의 값은 : %d \n", r1);
      printf("r2의 값은 : %d \n", r2);
      printf("r3의 값은 : %d \n", r3);
      printf("r4의 값은 : %d \n", r4);

      return 0;

> 결과
r1 : 2
r2 : 4
r3 : 8
r4 : 16

의 값이 나옴을 확인할 수 있다. 연산결과는 한 칸 왼쪽으로 옮길 때 마다 곱하기 2씩 되는 것을 확인할 수 있다. 2진수로 표현된 비트열을 한 칸 씩 옮기기 때문에 값이 두배 씩 증가하게 되는 것임

<br>

이런 방식을 이용하여 연산 속도가 느린 곱하기, 나눗셈에
사용하곤 한다.

<br>

같은 방식으로 비트열을 오른쪽으로 이동시키면 나누기 2씩 값이 감소한다. 그리고 오른쪽으로 이동할 때 값이 홀수이면 0.5는 잘려나간다. 또한 오른쪽으로 옮기면서 비트열에서 탈락되는 값들은 버린다. 그렇게 나머지 값을 버리기 때문에 정수형 나눗셈을 한다고도 볼 수 있다.

* -값 정수의 비트열을 오른쪽으로 옮기는 경우

보통 비트열을 오른쪽으로 옮기면 왼쪽 비트에는 0을 넣게 되지만 -값 같은 경우 첫번째 비트에 부호정보가 담겨있기 때문에 이럴 때는 첫 비트에 0이 아닌 1이 생긴다.

* 비트 연산자들의 활용

비트마스크 : 비트의 열에다가 씌울 수 있는 마스크
> 활용. 마스크를 잘 활용하면 비트 열의 특정부분을 뽑아낼 수 있다.


      short data = 0x5678;    /* 0101 0110 0111 1000

      short mask1 = 0xf000;   /* 1111 0000 0000 0000
      short mask1 = 0x0f00;   /* 0000 1111 0000 0000
      short mask1 = 0x00f0;   /* 0000 0000 1111 0000
      short mask1 = 0x000f;   /* 0000 0000 0000 1111

      printf("result1 : %.4x \n ", data & mask1);
      printf("result2 : %.4x \n ", data & mask2);
      printf("result3 : %.4x \n ", data & mask3);
      printf("result4 : %.4x \n ", data & mask4);

> 의 결과값은  
    result1 : 0x5000
    result2 : 0x0600
    result3 : 0x0070
    result4 : 0x0008

위의 코드는 mask1,2,3,4를 이용하여 data의 비트열을 4비트씩 나누어 표현하였다. 이런 방식으로 비트열의 특정 부분을 뽑아낼 수 있는 것이다.

> 보통 프로그래머는 구조적으로 안정된 코드를 작성하기 위하여 전역변수에 직접 접근하는 것을 최대한 자제하고 전역변수에 저장되는 값을 변경한느 별도의 함수를 만들어 사용한다.

위 비트마스크는 설정해야 할 정보가 많이 필요하나 상황에서 많이 사용된다.
