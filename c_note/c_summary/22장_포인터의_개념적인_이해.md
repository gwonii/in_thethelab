## 포인터의 개념적인 이해

### 22.1 포인터는 메모리의 주소와 아주 깊은 관련이 있다.
---


* 포인터란?

"포인터는 주소 값을 담고 있는 변수입니다." 다시 말해 주소 값을 담을 수 있는 변수나 주소 값을 의미하는 상수를 가리켜 포인터라 한다는 것이다.


* 메모리의 주소체계

보통 0x123ff23 이라는 주소 값이 가리키는 메모리 공간의 크기는 64bit 체계에서 8바이트로 표현되는 것으로 알고 있는데 (여기서는 1바이트라고 하네 좀 더 이해해보자) 여기서 말하는 주소 "하나의 주소 값" 이 8비트로 1바이트라고 말하고 있는 것이다.

* 주소 값을 표현하는데 필요한 바이트 수

주소 값에 필요한 바이트 수는 표현하고 싶은 주소 값의 범위에 따라서 달라진다. 주소 값의 바이트 수가 크면 클수록 보다 넓은 메모리 공간에 주소 값을 부혀할 수 있다.

* 주소 값을 할당해야만 메모리 공간을 활용할 수 있나?

메모리 공간을 실제로 활용하는 주체는 운영체제이다. 그리고 운영체제는 메모리 공간을 관리하기 위해서 주소 값을 할당한다. 따라서 주소 값이 할당되지 않으면 메모리 공간은 운영체제에서 활용할 수 없는 메모리 공간이 되버린다.

* 32/64 bit 시스템

32bit 시스템에서 주소 값의 표현에 4바이트가 사용되고 64bit 시스템에서는 8바이트가 사용된다.


### 22.2 포인터 변수 선언하기
---

* 주소 값을 얻기 위해 사용되는 & 연산자

&가 단항연산자로 사용되면, 피연산자의 주소 값을 반호나하는 기능의 연산자가 된다.

> c_code 22_2.

* 포인터 변수 선언의 기본 규칙

          TYPE val;
          이라는 변수가 있고

          TYPE *ptr;     **
          TYPE형 변수의 주소 값을 저장하는 포인터 변수 ptr

          초기화
          ptr = &val;
          or
          TYPE *ptr = &val;     **

* 포인터와 변수의 메모리상 관계

포인터 변수 ptr의 크기는 어떤 TYPE의 주소 값을 나타내고 있던지 간에 항상 8바이트의 크기를 가지고 있다.

### 22.3 포인터 형(type)과 *연산자  **
---

* 포인터 형이란?

      표현
      int *      int형 포인터 **
      char *     char형 포인터 **
      double *   double형 포인터 **

> 이것이 포인터 형의 이름

> 예시 22_3.c, 22_4.

* int형 변수에 주소 값을 저장하면 안되는 이유

"포인터 형은 포인터가 가리키는 메모리 공간의 데이터 저장 및 참조 방식을 결정한다."  핵심은 가리키는 대상에 따라 변화하는 것이 아니라 포인터 형에 맞게 저장되는 것이다. 포인터는 주소 값만 가지고 있는 것이 아니라 메모리에 대한 정보 (어떻게 접근,참조 해야 하는지에 대한 정보)를 가져야 하는 것이다.

* 포인터 변수도 값의 변경이 가능하다.

* 초기화되지 않은 포인터는 어디를 가리킬지 모른다.

항상 포인터는 초기화를 해주어야 그에 상항하는 데이터 공간을 할당 받는다. 초기화 되지 않으면 위치도 알 수 없고 정보도 알 수 없기 때문에 쓰레기 값들이 나올 수 있다. 그래서 NULL을 이용하여 초기화 하는 경우가 있음. NULL을 사용하지 않으면 "어디를 가리키고 있는지 모르지만" 사용하면 "아무 곳도 가리키고 있지 않습니다" 라는 것을 알 수 있기 때문이다.

### 22.5 &연산을 통해 얻은 주소 값은 단순한 숫자가 아니다
---

* &연산자가 반환하는 것은 상수 형태의 포인터

"포인터는 주소 값을 지니며, 더불어 참조하는 대상의 자료형 정보도 지니는 변수나 상수를 의미한다." 중요한 것은 주소 값과 대상의 자료형 정보

> 22_9.c

&연산을 하고 *연산을 이용하여 주소 값에 해당하는 메모리 영역에 접근을 해서 값을 증가시켰다.
**

* 포인터의 형 변환

겨웅에 따라 포인터의 형을 변환해야 하는 경우가 있다. 대부분 자동적으로 이루어지지만 경우에 따라 강제적으로 해야되는 경우가 있다.

      int main (void) {

        int num = 10;
        char *p = &num;
      }

**
> 위의 코드는 자연스럽게 int*에서 char*으로 형변환 된다. &연산의 결과로 반환되는 값은 int형 변수의 주소 값인 반면 이 값을 저장하는 포인터 변수 p는 char형 포인터 변수 이기 때문이다.

      char * p = (char *) &num;
**
> 이런 방식으로 강제적으로 형변환을 시킬 수 있다.

### 22.6 문자열 배열과 문자열을 참조하는 포인터
---

c언어에서 문자열을 표현하는 방식은 두 가지, 하나느 변수형태로 표현하는 것이고, 하나는 상수 형태로 표현하는 것이다.

* 배열을 이용해서 선언하는 문자열은 변수 형태의 문자열이다.

      char vStr[30] = "string variables";

> char형 배열을 통해서 문자열이 표현된다. 배열에 문자들이 저장되는 것

* 포인터를 이용해서 상수 형태의 문자열을 참조하는 것도 가능하다.

      char *cStr = "string variables";

**
> 위와 같이 포인터를 이용해서 문자열을 상수화하는 것도 가능하다.
> 배열로 표현되지 않은 문자열은 상수의 형태로 메모리 공간에 저장된다. 메모리 공간에 자동적으로

> 예제 22_10.c

* 문자열 상수라는 증거 제시하기

> 예제 22_11.c

      char *cstr = "string";
      *cstr = 'q';
      printf("%S \n ", cstr);
**

> 위의 코드에서는 에러가 생긴다. 왜냐하면 char *cstr로 문자열을 선언하는 것은
문자열을 상수형으로 저장하는 것이기 때문에 변할 수 없다. 그런데 그것을 의도적으로
변경하려고 하기 때문에 제대로 출력되지 않는다.
