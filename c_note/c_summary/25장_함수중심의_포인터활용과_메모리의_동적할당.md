## 25장 함수 중심의 포인터 활용과 메모리의 동적할당

### 25.1 call-by-value vs call-by-reference
---

포인터는 함수 호출시 배열의 주소 값을 전달하거나 문자열을 표현하는 것 이외에도 중요하게 사용된다. 

* 포인터를 이용하면 함수 내에서 외부에 있는 변수에 직접 접근이 가능하다. 

> 예제 25_1.c

예제에서 볼 수 있듯이 
call-by-value의 경우 함수내에서 매개변수를 이용하여  변수의 값을 조정하여도 main 함수네에서 그 변수 값은 바뀌지 않는다. 하지만
call-by-reference의 경우 함수내에서 매개변수를 이용하여 변수의 값을 조정하면 main 함수 속의 변수 값 또한 변한다. 
> 주소 값으로 접근하여 값을 바꾸면 해당하는 주소의 변수 값이이 계속 바뀌어 있지만 단순히 값을 바꾼다는 것은 임의의 새로운 변수를 바꾸는 것이기 때문에 main 함수 속 변수에는 영향을 못주는 것이다. 

* call-by-reference를 이용한 swap 함수 

> 예제 25_3.c 

포인터를 이용하게 되면 원하는 값들을 쉽게 바꿀 수 있다. 


### 25.2 자료형에 이름을 부여하는 typedef 
---

* typedef 키워드를 이용해서 자료형에 새 이름을 부여한다. 

			(정의하기)         (이 이름으로) 
			typedef    TYPE      NAME;
				 (해당 자료형에게)    

**주의사항**
1. 둘 이상의 단어로 구성된 이름들은 새로운 이름으로 사용 불가능하다. 
2. 이미 typedef 한 이름과 다른 이름을 섞어서 쓸 수 없다.    
> ex) typedef int* PINT 는 가능하지만, typedef unsigned PINT uptr 

* 배열 형에 typedef 선언하는 방법 

			double DRB5 [5];
			는 double형 길이가 5인 배열이다. 이름이 DRB5인 
			그런데 
			typedef double DRB5 [5];
			는 의미가 아예 달라진다. double [5] 의 이름을 DRB5라고 정의한다는 것이다 .

			ex) 
			double arr [5] 는 DRB5 arr와 동일하다. 

> 예제 25_5.c

typedef을 1차원 배열과 2차원 배열에 이용하여 예제로 만들어 보았다. 

* 2차원 배열의 typedef
			
			먼저 
			int (*I2ARR3) [3]; 은
			가로의 길이가 3인 int형의 2차원 배열을 가리킬 수 있는 포인터 변수가 된다.  

			typedef int (*I2ARR3)[3]; 은 
			int형 가로길이 3인 2차원 배열의 포인터 이름을 대신한다. I2ARR3이 


* 모든 프로젝트에서는 typedef로 자료형을 정의하는 것이 일반적이다. 


### 25.3 메모리 공간의 동적할당 
---

* 메모리 구조에 대한 복습 

1. 코드영역 : 실행할 프로그램의 코드를 올려 놓을 공간
2. 데이터 영역: 프로그램이 종료될 때까지 유지해야 할 데이터를 저장할 공간
3. 스택 영역: 아주 잠깐 사용하고 삭제할 데이터의 저장공간
4. 힙 영역: 프로그래머가 원하는 형태로 쓸 수 있는 공간

여기서 다룰 영역은 "힙 영역" 데이터 영역이나 스택 영역에 사용하지 못하는데 데이터들을 사용하는 공간

* 지역변수와 전역변수가 갖는 한계

배열을 함수의 반환값으로 하여 메인에서  연산을 하려고 할 때 메인 함수에서 배열 함수의 반환값이 이미 소멸해버렸기 때문에 사용할 수 가 없다. 이런 배열은 지역변수나 전역변수로 둘다 사용하기가 힘들다. 

*한계를 벗아나게 해주는 힙 영역 "동적 할당" 

힙 영역의 경우 시스템이 관여하지 않지만, 내가 메모리를 할당하였다면 다 사용한 후에 그 할당한 영역을 없애줘야 한다. 힙 영역은 자동적으로 없어지지 않기 때문에 꼭 인위적으로 없애야 한다. 

* 동적 할당에 사용되는 함수는 "malloc"

			#include <stdlib.h>
			void *malloc(size_t size);
			성공 시 할당된 메모리의 주소 값, 실패 시 NULL값 반환

> size_t는 typedef에 의해 만들어진 자료형이다. 일반적으로 unsigned int 또는 unsigned long 으로 선언되어 있어서, 말 그대로 사이즈에 대한 정보를 담기 위한 자료형이다. 
> 할당된 힙 영역에 접근하기 위해서는 불가피하게 포인터 연산을 해야한다. 
> 프로그램의 안정성을 위하여 메모리를 할당한 후에 항상 NULL반환 여부를 확인 할 것!

* malloc 함수가 주소 값의 포인터 형을 어떻게 결정하는가? 

"malloc 함수는 반환되는 주소 값의 포인터 형을 결정하지 못한다." 
때문에 포인터 형이 결정되지 않은 주소 값만을 반환할 수 있다. 그리고 이러한 값을 반환하기 위해서 사용되느 것이 "void *" 이다. 

			void *ptr = malloc(sizeof(int));
			*ptr = 10;
> 위의 코드는 오류가 생긴다. malloc 함수를 통해서 ptr에 int 크기 만큼의 공간을 만들어 주었지만 자료형이 정해지지 않아, 10이라는 값을 int형인지 double형인지 float형인지 알 수 없어 에러가 발생한다. 

이것을 해결하기 위해 
			void *vptr = malloc(sizeof(int));
			int *iptr = (int *) vptr; 
			을 통해서 
			*iptr = 10; 

> 위으 방식으로 정상적으로 동적 할당한 데이터 공간을 사용할 수 있다. 
> void * 로 저장한 것을 임의적으로 int *로 다시 저장시키는 것이다. 

이것을 한 줄로 요약하면 
			int *iptr = (int*)malloc(sizeof(int));

> 이런 식의 코드를 사용한다. 

* free 힙을 사용하는데 있어서 주의사항 

			#include <stdlib.h>
			void free(void *ptr)

할당된 메모리 공간을 다 사용한 후 free 함수를 통해서 다시 메모리를 해지해줘야 한다. 


* malloc 함수의 모범적인 예 

> 예제 25_7.c

예제 25_7.c를 참고로 malloc의 동적 할당에 대해 조금 더 반복적으로 이용해 볼 것!

* malloc과 유사한 calloc

			#include <stdlib.h>
			void *calloc(size_t elt_count, size_t elt_size);
			성공시 할당된 메모리의 주소 값, 실패시 NULL 반환 

> calloc은 두 개의 인자를 사용하여 앞의 인자는 개수를 넣어주고, 뒤의 인자에는 사이즈 정보를 입력해준다. 그렇게 되면 malloc은 자료형이 정의되지 않아 (int*)등을 통해 의도적인 캐스팅을 했지만 calloc의 그것이 필요 없는 것이다. 

* 힙에 할당된 메모리의 확장 시 호출하는 realloc 함수 

			#include <stdlib.h>
			void *realloc(void *ptr, size_t size);
			성공시 새로 할당된 메모리의 주소 값, 실패 시 NULL 반환 

> 예제는 패스 























