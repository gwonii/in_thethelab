# 6장 객체지향 프로그래밍1

### 6.4 메소드 오버로딩 
---

* 오버로딩의 장점

보통 유사한 메소드의 경우, 메소드를 사용하는데 있어서 이름 짓기도 힘들 뿐더러 사용할 때 마다 이름을 기억하기 어렵다. 그렇기 때문에 유사한 메소드의 경우 오버로딩을 통해 유사한 메소드를 같이 정리하는 것이다. 

ex) println 같은 경우도 다양한 매개변수를 받는 여러 개의 메소드를 합쳐놓은 오버로딩의 대표적인 예이다. 

* 생성자 (constructor)

- 생성자는 인스턴스가 생성될 때 호출되는 "인스턴스 초기화 메소드"이다. 생성자도 메소드의 한 종류임. 

- 보통 변수 초기화에 주로 사용되며, 인스턴스 생성시 기본적으로 실행되어야 하는 것들이 담겨있다. 

* 생성자의 특징 
	1. 생성자의 이름은 메소드의 이름과 동일해야 한다. 
	2. 생성자는 리턴 값이 없다. 


> 연산자 new가 생성자를 생성하는 것이지, 생성자가 인스턴스를 만드는 것이 아니다. 


* 생성자 생성 과정

			Card c = new Card();

1. 연산자가 new에 의해서 메모리(heap)에 Car 클래스의 인스턴스가 생성된다. 
2. 생성자 Card() 호출되어 수행된다. 
3. 연산자 new의 결과로, 생성된 Card 인스턴스의 주소가 반환되어 참조변수 c에 저장된다. 

> 하나의 클래스에는 반드시 하나의 생성자가 존재해야 한다. 그러나 지금까지 생성자를 만들지 않았음에도 불구하고 클래스를 만들 수 있었던 이유는 "기본 생성자"라는 것이 존재하기 때문이다. 

기본 생성자는 class와 이름만 동일하고, 매개변수도 받지 않으면 내용또한 빈 공간으로 만들어졌다. 


* 매개변수가 있는 생성자

생성자에도 배개변수를 추가할 수 있다. 

			class Car {

					Car(int x, int y) {

							~~~
					}
			}

> 이러면 나중에 객체를 만들 때는 

			Car car = new Car(a,b);  로 객체를 만들어야 한다.
			// a와 b는 int형 변수다. 


* 생성자에서 다른 생성자 호출하기 ( this(), this )

조건 
	- 생성자의 이름으로 클래스이름 대신 this를 사용한다. 
	- 한 생성자에서 다른 생성자를 호출할 때 반드시 첫줄에서만 호출이 가능하다. 

			Class Car {

					String color;
					String gearType;
					int door;

					Car () {

							this( "white" , "auto" , 4);

					}

					Car (String color) {

							this ( color , "auto" , 4);
					}

					Car (String color , String gearType , int door) {

							this.color = color;
							this.gearType = gearType;
							thisdoor = door;
							// 인스턴스의 변수 이름 color와 매개변수로 받는 color를 구분해 주기 위해 this를 사용하였다. 

					}

			}

> 이렇게 여러 개의 생성자를 쓰고 싶을 때, 동시에 클래스 안에 있는 생성자를 쓰고 싶을 때 this를 통해서 클래스 내에 있는 다른 생성자를 생성자로 만들 수 있다. 


- this : 인스턴스 자신을 가리키는 참조변수, 인스턴스의 주소가 저장되어 있다. 모든 인스턴스메소드에 지연변수로 숨겨진 채 존재한다. 
- this(), this(매개변수) : 생성자, 같은 클래스의 다른 생성자를 호출할 때 사용한다. 


* 생성자를 이용한 인스턴스의 복사

			Car(Car c) {

					color = c.color;
					gearType = c.gearType;
					door = c.door;

			}

> 위 코드를 보면, Car라는 생성자의 매개변수로 인스턴스 Car c를 사용하고 있다 위 말은 인스턴스를 생성할 때 Car c와 같이 인스턴스를 복사하고자 할 때 사용된다. 

> 보통 자바에서 많이 사용되는 API들은 클래스들의 인스턴스의 복사를 위한 생성자를 만들어 놓고 사용한다. 


#### 인스턴스를 생성할 때 결정해야 할 2가지 사항 
- 클래스 : 어떤 클래스의 인스턴스를 생성할 것인가? 
- 생성자 : 선택한 클래스의 어떤 생성자로 인스턴스를 생성할 것인가? 

* 멤버 변수의 초기화 방법 
	(멤버 변수는 클래스, 인스턴스 등 의 속해있는 변수로 생각하면 된다. ) 

1. 명시적 초기화 ( 변수의 직접 선언)
2. 생성자
3. 초기화 블럭 (인스턴스 초기화 블럭 / 클래스 초기화 블럭 )



* 변수의 초기화 

보통 변수를 사용할 때는 선언과 동시에 초기화 하는 것이 좋다. 


> 인스턴스 변수는 초기화 하지 않으면, int의 경우 자동적으로 0 값을 초기화 한다. 


* 명시적 초기화 

변수를 선언하는 동시에 초기화하는 것을 명시적 초기화라고 한다. 

명시적 초기화가 간단하고 명료하긴 하지만, 보다 복잡한 초기화 작업이 필요할 때는 생성자 또는 초기화 블럭을 사용한다. 

* 초기화 블럭 

- 클래스 초기화 블럭 
- 인스턴스 초기화 블럭 

			Class InitBlock {

					static { ~~~ }		// 클래스 초기화 블럭 

					{ ~~~ } 			// 인스턴스 초기화 블럭 

			}

> 위 코드처럼 { }안에 초기화 항목들만 넣어주면 된다. 거기에 static이 들어각면 클래스 초기화 블럭, 아무것도 사용하지 않으면 인스턴스 초기화 블럭 

> 클래스 초기화 블럭은 메모리에 처음 로딩될 때 한번만 수행되며, 인스턴스 초기화 블럭은 객체가 생성될 때 마다 메모리에 저장된다. 

* 맴버변수의 초기화 시점과 순서 

- 클래스 변수의 초기화시점 : 클래스가 처음 로딩될 때 단 한번만 초기화된다. 
- 인스턴스변수의 초기화시점 : 인스턴스가 생성될 때 마다 각 인스턴스별로 초기화가 이루어진다. 

- 클래스 변수의 초기화 순서 : 기본 값 -> 명시적 초기화 -> 클래스 초기화 블럭
- 인스턴스 변수의 초기화 순서 : 기본 값 -> 명시적 초기화 -> 인스턴스 초기화 블럭



































