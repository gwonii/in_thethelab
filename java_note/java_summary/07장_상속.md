## 7장 상속

### 7.1 상속 개념 
---

- 프로그램에서는 부모클래스를 상위 클래스라고 하고, 자식 클래스를 하위 클래스라고 한다. 

- 상속은 이미 잘 개발된 클새를 재사용해서 새로운 클래스를 만들기 때문에 코드의 중복을 줄여준다. 

- 부모 클래스에서 private 접근 제한을 갖는 필드와 메소드는 상속 대상에서 제외된다. 

- 부모 클래스의 수정으로 모든 클래스들의 수정 효과를 가져올 수 있기 때문에 유지보수의 시간을 최소화 시킬 수 있다. 


### 7.2 클래스 상속 
--- 

- extends를 이용하여 클래스를 상속 시킨다. 

			public class A extneds B {

					//어쩌구 저쩌구 

			}

- 자바는 다중 상속을 허용하지 않는다. 


### 7.3 부모 생성자 호출 
--- 

- 현실에서 부모 없는 자식이 없듯이 자바에서도 자식 객체를 생성하면, 부모 객체가 먼저 생성되고 자식 객체가 그 다음에 생성된다. 

- 부모 객체 또한 반드시 생성자가 호출되어야 한다. 기본적으로 자식 클래스 최상단에는 

			super();

이 생략되어 있다. 그렇기 때문에 자식 클래스를 객체화 하려고 할 때 자동적으로 부모 클래스의 생성자가 호출된다. 

- 그런데 만약 부모 클래스에 기본 생성자가 없고 특정 매개변수를 받는 생성자만 존재 한다면 자식 클래스에서 super ( 매개변수 a, 매개변수 b ); 를 선언해주여야 한다. 그렇지 않으면 부모 클래스의 생성자를 불러오지 못하고 에러가 발생한다.

			//부모 클래스 
			public class People {

					public String name;
					public String ssn;

					public People(String name, String ssn) {

							this.name = name;
							this.ssn = ssn;
					}

> 이런 형식으로 부모 클래스의 생성자가 만들어져 있다면 자식 클래스에서 반드시 

				
			super ( name, ssn );  

> 부모 클래스의 생성자를 호출해야 한다. 


### 7.4 메소드 재정의 
---

- 어떤 메소드는 자식 클래스가 사용하기에 적합하지 않을 수도 있다. 자바는 이런 경우를 위해 오버라이딩(overridng) 기능을 사용한다. 

#### 7.4.1 메소드 오버라이딩 규칙 

1. 부모의 메소드와 동일한 선언부 ( 리턴 타입, 메소드 이름, 매개 변수 리스트 )를 가져야 한다. 
2. 접근 제한을 더 강하게 오버라이딩 할 수 없다. 
3. 새로운  예외를 throws할 수 없다. 

- 부모 메소드가 public 접근 제한을 가지고 있을 경우 오버라이딩하는 자식 메소드는 default 나 private 접근 제한으로 수정할 수 없다. 자식 클래스가 같거나 더 넓어야 한다. 

#### 7.4.2 부모 메소드 호출 (super)

- 자식 클래스 내부에서 오버라이딩된 부모 클래스의 메소드를 호출해야 하는 상황이 발생한다면 명시적으로 super 키워드를 붙여서 부모 메소드를 호출 시킬 수 있다. 

- 자식 클래스에서 메소드를 오버라이딩 한다면 이제 부모클래스에게 상속받은 것이 아닌 다른 메소드가 된 것 

### 7.5 final 클래스와 final 메소드 
--- 

- fianl 키워드는 클래스, 필드, 메소드 선언 시에 사용할 수 있다. 

#### 7.5.1 상송할 수 없는 final 클래스 

- 클래스를 선언할 때 final 키워드를 class 앞에 붙이게 되면 이 클래스는 최종적인 클래스이므로 상속할 수 없는 클래스가 된다. 

#### 7.5.2 오버라이딩 할 수 없는 final 메소드 

- 메소드 선언시 final 키워드를 붙이면 메소드는 최종적인 메소드이므로 오버라이딩 할 수 없는 메소드가 된다. 


> 클래스에 final을 붙이면 앞으로 다른 자손 클래스에 상속해줄 수 없는 것이고, 메소드에 final을 붙이면 자손 클래스에서 오버라이딩 할 수 없다는 것이다. 

### 7.6 접근 제한자 
--- 

- public, protected, default, private 

### 7.7 타입 변환과 다형성 
--- 

- 다형성은 같은 타입이지만 실행 겨로가가 다양한 객체를 이요할 수 있는 성질을 말한다. 

- 타입 변환이란 데이터 타입을 다른 데이터 타입으로 변환하는 행위를 말한다. 

- 클래스 타입의 변환은 상속 관계에 있는 클래스 사이에서 발생한다. (자식 -->  부모)

- 자동 타입 변환의 개념은 부모의 특징과 기능을 상속받기 때문에 부모와 동일한 취급을 받을 수 있다. 

- 부모 타입으로 자동 타입 변환된 이후에는 부모 클래스에 선언된 필드와 메소드만 접근이 가능하다. 

- 예외가 있는데, 메소드가 자식 클래스에서 오버라이딩되었다면, 자식 클래스의 메소드가 대신 호출된다. 

#### 7.7.1 필드의 다형성 

- 다형성이란 동일한 타입을 사용하지만 다양한 결과가 나오는 성질 

- 주로 필드의 값을 다양화함으로써 실행 결과가 다르게 나오도록 구현하는데, 필드의 타입은 변함이 없지만, 실행 도중에 어떤 객체를 필드로  저장하느냐에 따라 실행결과가 달라질 수 있다. 

- 프로그램은 수 많은 객체들이 서로 연결되고 각자의 역할을 하는데, 이 객체들은 다른 객체로 교체될 수 있어야 한다. 

#### 7.7.2 하나의 배열로 객체 관리 

- 배열을 통해서 객체들을 관리할 수 있다. 

			class Car {

					Tire frontLeft = new Tire("앞왼쪽");
					Tire frontRight = new Tire("앞으른쪽");
					Tire rearLeft = new Tire("뒤왼쪽");
					Tire rearRight = new Tire("뒤오른쪽");
			}

> 위의 객체들을 

			class Car {

					Tire[] tires = {

							new Tire("앞왼쪽");
							new Tire("앞오른쪽");
							new Tire("뒤왼쪽");
							new Tire("뒤오른쪽");
					}
			}

> 이런 식으로 배열의 형태로 객체를 담아놓을 수 있다. 그러면 나중에 객체를 이용할 때도 훨씬 쉽게 이용할 수 있다. 

#### 7.7.3 매개변수의 다형성 

- 자동 타입 변환은 필드의 값을 대입할 때에도 발생하지만, 주로 메소드를 호출할 때 많이 발생한다. 

- 매개값을 다양화하기 위해 매개 변수에 자식 타입 객체를 지정할 수도 있다. 

			class Driver {

					void drive (Vehicle vehicle) {

							vehicle.run();
					}
			}

			Driver driver = new Driver();
			Vehicle vehicle = new Vehicle();

			drvier.drive(vihicle);

> 그런데 만약 매개변수로 vihicle이 아닌 vihicle의 자손 클래스인 Bus의 객체가 들어 온다면? 

			Bus bus = new Bus();
			dirver.drive(bus);

> 매개변수의 다형성에 의해 매개 변수의 정의가 Vehicle로 되어 있지만 bus가 들어올 수 있다.그러면 자동적으로 Vehicle vehicle = bus; 로 자동 타입 변환이 발생한 것 이다. 

#### 7.7.5 강제 타입 변환 (casting)
	
- 강제 타입 변환은 부모 타입을 자식 타입으로 변환하는 것을 말한다. 

			
			Vehicle vehicle = new Bus();
			// 자식 클래스로 선언을 해놓은 경우에만 강제 형변환이 가능하다. 
			// 다시 자식 클래스의 필드와 메소드가 필요한 경우에 

			Bus bus = (Bus) vehicle();

> 만약 자식 타입에 선언된 필드와 메소드를 꼭 사용해야 한다면 강제 타입 변환을 해서 다시 시작 타입으로 변환한 다음 자식 타입의 필드와 메소드를 사용하면 된다. 

#### 7.7.6 객체 타입 확인 (instanceof) 

			Parent parent = new Parent();
			Child child = (Child) parent; 	// 불가능 에러가 발생한다. 

- 어떤 객체가 어떤 클래시의 인스턴지인지 확인하려면 instanceof 연산자를 사용할 수 있다. 
	
- instanceof 연산자는 매개값의 타입을 조사할 때 주로 사용된다. 

			boolean result = (객체) instanceof (타입)

> 반환값은 true / false 


### 7.8 추상 클래스
---

- 추상은 실체 간에 공통되는 특성을 추출한 것을 말한다. 

- 추상 클래스는 new 연산자를 사용해서 인스턴스를 생성시키지 못한다. 

#### 7.8.1 추상 클래스의 용도 

1. 실체 클래스들의 공통된 필드와 메소드의 이름을 통일할 목적 
	- 실체 클래스를 설계하는 사람이 여러 사람일 경우, 실체 클래스마다 필드와 메소드가 제각기 다른 이름을 가질 수도 있다. (이런 문제점을 해결하기 위하여 추상 클래스 사용) 
	
2. 실체 클래스를 작성할 때 시간을 절약하기 위하여 
	- 공통적인 필드와 메소드는 추상클래스에 모두 선언해 두고, 실체 클래스마다 다른 점만 실체 클래스에 선언하게 되면 실체 클래스를 작성하는데 시간을 절약할 수 있다. 

#### 7.8.2 추상 클래스 선언 

- abstract를 붙이게 되면 new 연산자를 이용해서 객체를 만들지 못하고 상속을 통해 자식 클래스만 객체를 만들 수 있다. 

			public abstract class (클래스) {

					//필드 

					//생성자 

					//메소드 
			}

> 추상 클래스도 실체 클래스와 마찬가지로 필드, 생성자, 메소드를 선언할 수 있다. 

#### 7.8.3 추상 메소드와 오버라이딩 

- 추상클래스는 실체 클래스가 공통적으로 가져야 할 필드와 메소드들을 정의해 놓은 추상적인 클래스이므로 실체 클래스의 멤버(필드, 메소드)를 통일화하는데 목적이 있다. 

- 추상 메소드는 메소드의 선언부만 있고 메소드 실행 내용인 중괄호 { }가 없는 메소드를 말한다. 

- 추상 클래스를 설계할 때, 하위 클래스가 반드시 실행 내용을 채우도록 강요하고 싶은 메소드가 있을 경우, 해당 메소드를 추상 메소드로 선언하면 된다. 

- 추상 메소드도 메소드 앞에 abstract를 넣어주면 된다. 그러면 하위 클래스에서 만드시 그 메소드를 정의하고 사용해야 한다. 






















































