# 7장 객체지향 프로그래밍2

### 7.1 상속 (ingeritance)
---

* 상속의 정의와 장점

- 상속이란, 기존의 클래스를 재사용하여 새로운 클래스를 만드는 것이다. 


- 상속을 이용하면 코드의 반복을 줄일 수 있고, 그러면 좀더 간결하고 짧은 코드를 작성할 수 있다. 


- 상속 받는 클래스를 자식 클래스, 상속 해주는 클래스를 부모 클래스라고 한다. 


- 자식 클래스는 부모 클래스가 갖고 있는 맴버들을 상속받기 때문에 상속을 시키면 자연스럽게 부모 클래스가 갖고 있는 맴버들을 가지고 있는다. 


- 부모 클래스에 변화가 생기면, 자손 클래스에 변화를 주지만 자손 클래스가 변화해도 부모 클래스에는 변화가 생기지 않는다. 


요약
	- 생성자와 초기화 블럭은 상속되지 않는다. 멤버만 상속된다. 
	- 자손 클래스의 멤버 개수는 부모 클래스보다 항상 같거나 많다. 


- 두 자손 클래스가 하나의 부모 클래스를 동시에 상속받을 수 있다 
			class Parent {}
			class Child1 extends Parent {}
			class Child2 extends Parent {}


> 같은 부모 클래스를 상속받고 있다고 하더라도, 두 자식 클래스는 연관이 없다. 


- 자손 클래스를 상속받는 손자 클래스도 존재할 수 있다. 
			class Parent {}
			class Child extends Parent {}
			class GrandChild extends Child {}

> class Child는 Parent를 직접  상속받고, class GrandChild는 Parentf를 간접 상속 받고 있다. 간접 상속을 받더라도 class GrandChild는 Parent의 멤버를 모두 상속받고 있다. 


* 클래스 간의 관계 - 포함관계

			class Circle {

					int x;
					int y;
					int r;
			}

			class Point {

					int x;
					int y;
			}

> 위 코드처럼 중복되는 멤버를 사용하고 있을 때 클래스의 포함관계를 이용하여 코드를 효율적으로 작성할 수 있다. 

			class Circle {

					Point p = new Point();
					int r;
			}
			
			class Point {

					int x;
					int y;
			}	

> 위 코드처럼 코드가 중복이 일어나면 한 클래스에서 다른 클래스의 인스턴스를 생성하여 사용할 수 있다. 

#### 하나의 거대한 클래스를 작성하는 것 보다 단위별로 여러 개의 클래스를 작성한 다음에 , 이 단위 클래스들을 포함관계로 재사용하면 보다 간결하고 손쉽게 클래스를 사용할 수 있다. 


* 단일 상속 

자바에서는 다중 상속을 지원하지 않는다. 하나의 클래스는 부모 클래스를 하나만 가질 수 있다. 


단일 상속을 사용하므로써 다중 상속보다 불편한 점이 있을 수 있지만, 클래스 간의 관계가 보다 명확해지고 코드를 더욱 신뢰할 수 있게 만들어 준다. 

* object class 

모든 클래스의 최상위 부모 클래스는 object 클래스이다. 그렇기 때문에 별다른 import 없이 String toString 등 메소드를 사용할 수 있는 것이다. 


### 7.2 오버라이딩 (overriding)
---

* 오버라이딩이란? 
	부모 클래스로부터 상속받은 메소드의 내용을 변경하는 것을 오버라이딩이라고 한다. 


			class Point {

					int x;
					int y;

					String getLocation() {

							return "x : " + x + ", y : " + y;
					}
			}

			에서 오버라이딩을 하게 되면 

			class Point3D extends Point {

					int z;

					String getLocation() {

							return "x :" + x + ", y :" + y + ",z : " + z;
					}
			}

> 이런 식으로 상속 해준 부모의 클래스를 자식 클래스에서 변화시켜서 사용하는 것이다. 


* 오버라이딩의 조건 

자손 클래스에서 오버라이딩하는 메소드는 조상 클래스의 메소드와 
	- 이름이 같아야 한다. 
	- 매개변수가 같아야 한다. 
	- 리턴타입이 같아야 한다. 


1. 접근 제어자는 조상클래스의 메소드보다 좁은 법위로 변경할 수 없다. 
2. 조상클래스의 메소드보다 많은 수의 예외를 선언할 수 없다. 




### 7.4 제어자
---

제어자란
	제어자는 클래스, 변수 또는 메소드의 선언부에 함께 사용되어 부가적인 의미를 부여한다. 

* static 
	static은 클래스 변수를 만들어 낸다. static 변수가 붙은 멤버변수, 메소드, 초기화 블럭은 인스턴스가 아닌 클래스에 관계되게 된다. 

* static 사용처 
	멤버변수, 메소드, 초기화 블럭에 사용된다. 


* final
	변경될 수 없는 것을 의미한다. 

* final 사용처 
	클래스, 메소드, 멤버변수, 지역변수 어디든 사용될 수 있다. 

	-클래스: 클래스에 final이 사용되면 해당 클래스를 사용한 자손 클래스를 만들 수 없다. 
	-메소드 : 메소드에 사용되면 다른 클래스에서 오버라이딩 될 수 없다. 
	-멤버변수, 지역변수 : 변수에 사용되면 값을 변경할 수 없는 상수가 된다. 


* 생성자를 이용한 final 멤버변수 초기화 
	생성자를 이용하게 되면 클래스를 호출할 때 항상 기본적으로 작동을 하게 된다. 그러면 생성자의 매개변수를 받아 인스턴스마다 다른 final 값을 갖게하는 생성자를 만들 수 있다. 


* abstract 
	미완성의 의미를 가지고 있다. 메소드의 선언부만 작성하고 실제 수행내용은 구현하지 않은 추상 메소드를 선언하는데 사용된다. 


* abstrct 사용처 
	클래스, 메소드 

	- 클래스 : 클래스 내에 추상 메소드가 있다는 것을 알려주는 용도
	- 메소드 : 선언부만 작성하고 구현부는 작성되지 않은 상태임을 알려준다. 


* 접근 제어자  


1. private
	private 이 붙은 변수, 메소드는 해당 클래스에서만 접근이 가능하다.


2. default
	접근제어자를 별도로 설정하지 않는다면 접근제어자가 없는 변수, 메소드는 default 접근제어자가 되어 해당 패키지 내에서만 접근이 가능하다.


3. protected
	접근제어자가 protected로 설정되었다면 protected가 붙은 변수, 메소드는 동일 패키지내의 클래스 또는 해당 클래스를 상속받은 외부 패키지의 클래스에서 접근이 가능하다.


4. public
	접근제어자가 public으로 설정되었다면 public 접근제어자가 붙은 변수, 메소드는 어떤 클래스에서라도 접근이 가능하다.



> 접근 범위가 넓은 것에서 좁은 것 순으로 나열하면 public, protected, default, private 순이다. 


* 접근 제어자를 이용한 캡슐화 
	멤버에 접근 제어자를 사용하는 이유는 클래스의 내부에 선언된 데이터를 보호하기 위한 것이다. 


데이터를 외부에서 함부로 변경하지 못하도록 또는 내부작업을 위해 임시로 사용되는 멤버변수나 부분작업을 처리하기 위한 메소드 등의 멤버들ㅇ르 클래스 내부에 감추기 위한 것이다. 


* 생성자의 접근 제어자 
	생성자의 접근 제어자를 사용하므로써 인스턴스의 생성을 제한할 수 있다. 


ex) 만약 클래스의 생성자를 private 접근자를 이용하여 만들었다면, 외부에서 생성자에 접근할 수 없게 만들 수 있다. 대신 해당 클래스에서는 private static 인스턴스를 만들어 해당 클래스에서 어디서든 사용가능하게 만들 수 있다. 그러면 해당 클래스에서는 인스턴스를 만들지 않고도 호출을 할 수 있다. 

> 이 처럼 생성자를 통해 직접 인스턴스를 생성하지 못하게 하고 public 메소드를 통해 인스턴스에 접근하게 함으로써 사용할 수 있는 인스턴스의 숫자를 제한할 수 있다. 


* super
	super은 자손 클래스에서 조상 클래스로부터 상속받은 멤버를 참조하는데 사용되는 참조변수이다. 


조상 클래스로부터 상속받은 멤버도 자손 클래스 자신의 멤버이므로 super대신 this를 사용할 수 있다. 그래도 두 클래스의 멤버가 중복 정의되어 사용되어 둘의 구분이 필요하다면 super를 사용하는 것이 좋다. 


static 메소드는 인스턴스와 관련이 없다. 그래서 this와 마찬가지로 super 역시 static 메소드에서는 사용할 수 없고 인스턴스메소드에서만 사용할 수 있다. 


* this()와 super()도 생성자이다. 
	그러므로 this.~ 는 자신의 클래스에서 생성자를 만드는 것이고, super. ~는 상속 해주는 클래스의 생성자를 만드는 것이다. 


### 7.3 package와 import
---

* package 
	패키지란, 클래스의 묶음 

항상 어떤 클래스든지 간에 하나의 패키지에 속해 있어야 한다. 

패키지를 선언하지 않아도 되었던건, 패키지를 선언하지 않은 경우에 자동적으로 선언되는 패키지가 있기 때문 


* import
	소스코드를 작성할 때, 다른 패키지의 클래스를 사용하려면 패키지명이 포함된 클래스 이름을 사용해야 한다. 그것이 불편하다면 사용하는 것이 import 


기본적으로 다른 패키지에 있는 클래스를 사용하려고 할 때 플 클래스명을 사용해야 되지만 import를 통해 다른 패키지들을 불러올 수 있다. 
import는 패키지와 달리 여러 가지 것들을 import 할 수 있다. 


### 7.5 다형성 
--- 

* 다형성이란? 
	객체지향에서 다형성이란, 여러 가지 형태를 가질 수 있는 능력이라고 할 수 있다. 



// 다형성 부분이랑 인터페이스의 다형성 부분 다시 읽고 정리할 것 ! 

// 추상클래스랑 다형성 인터페이스 정리 해야됨 














