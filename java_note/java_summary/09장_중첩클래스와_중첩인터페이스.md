# 9장 중첩 클래스와 중첩 인터페이스 

## 9.1 중첩 클래스와 중첩 인터페이스란?
---

- 클래스들은 서로 긴밀한 관계를 맺고 상호작용을 한다. 클래스가 여러 클래스와 관계를 맺는 경우에는 독립적으로 선언하는 것이 좋다. 

- 하지만 특정 클래스와 관계를 맺을 경우에는 관계 클래스를 클래스 내부에 선언하는 것이 좋다. 

- 중첩 클래스 (nested class) 란 클래스 내부에 선얺나 클래스를 말한다. 

			class ClassName {

					class NestClassName}
						~~~
					}
			}

> 중첩 클래스 

			class ClassName {

					interface NestInterfaceName{

					}
			}

> 중첩 인터페이스 


- 중첩 인터페이스는 주로 UI프로그래밍에서 이벤트를 처리할 목적으로 활용된다. 


			public class View {

					public interface OnClickListener {

							public void onClick(View v);
					}
			}




## 9.2 중첩 클래스 
---

- 클래스의 멤버로서 선언되는 중첩 클래스를 "멤버 클래스"라고 하고, 메소드 내부에서 선언되는 중첩 클래스를 "로컬 클래스"라고 한다.

- 멤버 클래스와 로컬 클래스의 바이트 코드 파일 저장 형태 
			A $ B .class		// 멤버 클래스 

			A $1 B .class		// 로컬 클래스 

#
#### 9.2.1 인스턴스 멤버 클래스 

- 인스턴스 멤버 클래스는 인스턴스 필드와 메소드만 선언이 가능하고 정적 필드와 메소드는 선언할 수 없다. ( static을 사용할 수 없다. )

			class A {

					class B {

							B() {} 				// 생성자 
							int field1;			// 인스턴스 필드 
							static field2;		// 정적 필드 (x) 사용 불가능 
							void method1;		// 인스턴스 필드
							static method2; 	// 정적 메소드 (x) 사용 불가능 
					}
			}

> 이 인스턴스 멤버 클래스에 접근하려면 

			A a = new A();				// 먼저 class A의 객체를 생성하고 
			A.B = a.new B();			// class B의 객체를 생성한다. 

			b.field1;
			b.method1;

#
#### 9.2.2 정적 멤버 클래스ㅐ 

- 정적 멤버 클래스는 모든 종류의 필드와 메소드를 선언할 수 있다. 


			class A {

					static class C {

							B() {} 				// 생성자 
							int field1;			// 인스턴스 필드 
							static field2;		// 정적 필드도 선언 가능 
							void method1(){}	// 인스턴스 필드
							static method2(){} 	// 정적 메소드도 선언 가능 	
					}
			}

> 직접 사용을 해보면,

			A.C c = new A.C();
			c.field1 = 3;
			c.method1();
			A.C.field2 = 3;			// class C의 정적 필드 사용
			A.C.method2();			// class C의 정적 메소드 사용

#
#### 9.2.3 로컬 클래스 

- 메소드 내에 선언한 중첩 클래스를 로컬 클래스라고 한다. 

- 로컬 클래스는 메소드 내부에서만 사용되기 때문에 접근을 제한할 필요가 없다. 

- 로컬 클래스는 메소드가 실행될 때 메소드 내에서 객체를 생성하고 사용해야 한다. 



## 9.3 중첩 클래스의 접근 제한 
---

#

#### 9.3.1 바깥 필드와 메소드에서 사용제한 

- 멤버 클래스가 인스턴스 또는 정적으로 선언됨에 따라 바깥 클래스의 필드와 메소드에 사용 제한이 생긴다. 

- 인스턴스 멤버 클래스는 바깥 클래스의 인스턴스 필드의 초기값이나 인스턴스 메소드에서 객체를 생성할 수 있으나, 정적 필드의 초기 값이나 정적 메소드에서는 객체를 생성할 수 없다. 

#

#### 9.3.2 멤버 클래스에서 사용제한 

* 메법 클래스가 인스턴스 또는 정적으로 선언됨에 따라 멤버 클래스 내부에서 바깥 클래스의 필드와 메소드를 접근할 때에도 제한이 따른다. 

* 예시 
			인스턴스 멤버 클래스(B) 안에서는 바깥 클래스의 모든 필드와 모든 메소드에
			접근할 수 있지만, 정적 멤버 클래스(C) 안에서는 바깥 클래스의 정적 필드와 메소드에만
			접근할 수 있고, 인스턴스 필드와 메소드에는 접근할 수 없다. 

> 요약하자면 인스턴스 멤버 클래스는 바깥 클래스의 것들을 사용할 수 있다. 그러나 정적 멤버 클래스는 바깥 클래스의 것들을 자유롭게 사용할 수 없다 (특히 바깥 클래스의 인스턴스 필드와 메소드)

#

#### 9.3.3 로컬 클래스에서 사용 제한 

* 로컬 클래스 내부에서는 바깥 클래스의 필드나 메소드를 제한 없이 사용할 수 있다. 
	- 문제는 메소드의 매개 변수나 로컬 변수를 로컬 클래스에서 사용할 때

* 로컬 클래스의 객체는 메소드 실행이 끝나도 힙 메모리에 존재해서 계속 사용될 수 있다. 
	- 그러나 매개 변수나 로컬 변수는 메소드 실행이 끝나면 스택 메모리에서 사라진다. 그렇기 때문에 로컬 객체에서 위의 것들을 이용할 때 문제가 생긴다. 

* 자바는 이 문제를 해결하기 위해 컴파일 시 로컬 클래스에서 사용하는 매개 변수나 로컬 변수의 값을 로컬 클래스 내부에 복사해 두고 사용한다. 
	- 그리고 매개 변수나 로컬 변수가 수정되어 값이 변경되면 로컬 클래스에 복사해 둔 값과 달라지는 문제를 해결하기 위해 final 키워드를 사용한다. 

* 간단히 말하면 로컬 클래스에서 매개변수나 로컬 변수를 사용하고 싶다면, final 키워드를 사용해야 한다. 

* 자바 8에서는 로컬 클래스에 매개 변수와 로컬 변수에 final을 사용하지 않아도 에러가 나지 않는데 그것은 final을 쓰지 않아도 모두 final의 특성을 갖기 때문이다. 

#

#### 9.3.4 중첩 클래스에서 바깥 클래스 참조 얻기 

* 중첩 클래스에서 this를 사용하면 바깥 클래스의 객체 참조가 아니라, 중첩 클래스의 객체 참조가 된다. 

* 중첩 클래스 내부에서 바깥 클래스의 객체 참조를 얻으려면
			바깥 클래스.this.field
			바깥 클래스.this.method();


## 9.4 중첩 인터페이스 
---

* 중첩 인터페이스는 클래스의 멤버로 선언된 인터페이스를 말한다. 
	- 인터페이스를 클래스 내부에서 선언하는 이유는 해당 클래스와 긴밀한 관계를 맺는 구현 클래스를 만들기 위해서이다. 
	- 보통 UI프로그래밍에서 이벤트를 처리할 목적으로 자주 사용된다. 



## 9.5 익명 객체 
---

* 익명 객체는 이름이 없는 객체를 말한다. 익명 객체는 단독으로 생성할 수 없고 클래스를 상속하거나 인터페이스를 구현해야만 생성할 수 있다. 
	- UI 이벤트 처리 객체나 스레드 객체를 간편하게 생성할 목적으로 익명객체가 많이 활용된다. 

#

#### 9.5.1 익명 자신 객체 생성 

* 부모 타입으로 필드나 변수를 선언하고, 자식 객체를 초기값으로 대입하는 경우 
			
			class Child extends Parent { } 
			// 자식 클래스 선언 

			Class A {

					Parent field = new Child();
					// 필드에 자식 객체를 대입

					void method() {

							Parent localVal = new Child();
							// 로컬 변수에 자식 객체를 대입 
					}
			}

> 위에 코드는 자식 클래스가 재사용되지 않고, 오로지 해당 필드와 변수의 초기값으로만 사용할 경우라면 익명 자신 객체를 생성해서 초기값으로 대입하는 것이 좋은 방법 이다. 

			Class A {

					Parent field = new Parent() {

							int childField;
							void childMethod() {~~~}

							@override
							void parentMethod() {~~~}
					}
			}

* 로컬 변수로 선언할 때 

			Class {

					void method() {

							Parent field = new Parent(){

									int childField;
									void childMethod() {~~~}

									@override
									void parentMethod() {~~~}
							}
					}
			}


* 메소드의 매개 변수가 부모 타입일 경우 메소드 호출코드에서 익명 자신 객체를 생성해서 매개값으로 대입할 수도 있다. 

	class A{
		void method1(Parent parent) {~~~}

		void method2(){

			method1(
					new Parent() {

					int childField;
					void childField() {~~~}

					@override
					void parentField() {~~~}

					}
			)
		}

> 이런 방식으로 익명 자신 객체가 메소드의 매개 변수로 오는 경우도 있다. 

	
#

#### 9.5.2 익명 구현 객체 생성

* 인터페이스 타입으로 필드나 변수를 선언하고, 구현 객체를 초기값으로 대입하는 경우

			class TV implements RemoteControl {~~~}

			class A {

					RemoteControl field = new TV() {

							void method() {

									RemoteControl locarVal = new TV();
							}
					}
			}

> 이전과 마찬가지로 구현 클래스가 재사용되지 않고, 오로지 해당 필드와 변수의 초기값으로만 사용하는 경우면 익명 구현 객체를 초기값으로 대입하는 것이 좋다. 

			class A {

					RemoteControl fiedl = new RemoteControl() {

							@overrid
							void turnOn();
					}
			}

> 인터페이스 로컬 변수, 매개 변수로 사용되는 경우 위에 나와있는 예시와 동일하다. 

#

#### 9.5.3 익명 객체의 로컬 변수 사용

* 로컬 클래스와 익명 클래스는 이름의 표현에 대한 차이 빼고는 동일하게 작동한다. 

* 익명 객체 내부에서 메소드의 매개 변수나 로컬 변수로 사용할 경우, 이 변수들의 final의 특성을 갖는다. 


