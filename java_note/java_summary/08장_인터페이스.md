### 8.1 인터페이스의 역할 
--- 

- 인터페이스는 객체의 사용 방법을 정의한 타입이다. 인터페이스는 객체의 교환성을 높여주기 때문에 다형성을 구현하는 매우 중요한 역할을 한다. 

- 인터페이스는 개발 코드와 객체가 서로 통신하는 접점 역할을 한다. 개발 코드는 객체의 내부 구조를 알 필요가 없고, 인터페이스의 메소드만 알고 있으면 된다. 

- 개발 코드와 객체 사이에 인터페이스를 두는 이유는 개발 코드를 수정하지 않고 사용하는 객체를 변경할 수 있도록 하기 위해서이다. 


### 8.2 인터페이스 선언
---

- 인터페이스는 "~.java" 형태의 소스 파일로 작성되고, 컴파일러를 통해 "~.class" 형태로 컴파일 되기 때문에 물리적으로는 클래스와 형태가 동일하다. 

- 인터페이스의 선언은 class 키워드 대신 interface 키워드를 사용한다. 

			[ public ] interface (인터페이스 변수명) { ~~ }

- 인터페이스는 상수와 메소드만을 구성 멤버로 갖는다. 추가적으로 java8부터는 디폴트 메소드와 정적메소드도 선언이 가능하다. 

1. 상수 필드 
	- 인터페이스는 객체 사용 설명서이므로 런타임 시 데이터를 저장할 수 있는 필드를 선언할 수 없다. 그러나 상수 필드는 선언이 가능하다. 

2. 추상 메소드
	- 추상메소드는 객체가 가지고 있는 메소드를 설명한 것으로 호출할 때 어던 매개값이 필요하고, 리턴 타입이 무엇인지만 알려준다. ( 실행부는 구현 클래스에 담겨 있음)

3. 디폴트 메소드 
	- 인터페이스에 선언되지만 사실은 객체가 가지고 있는 인스턴스 메소드라고 생각해야 한다. ( 왜냐하면 디폴트 메소드는 기본적으로 구현 클래스가 다 가지고 있는 기본 메소드이지만 객체가 그것을 사용하지 않더라도 에러가 생기지 않기 때문에 인스턴스 메소드로 생각하라는 것이다. ) 

4. 정적 메소드 
	- 디폴트 메소드와 달리 객체가 없어도 인터페이스만으로 호출이 가능하다. 

#### 8.2.2 상수 필드 선언 

- 다시 말하지만 인터페이스는 데이터를 저장할 수 없다. 대신 상수 필드만 (public static final) 로 사용할 수 있다. 앞에 public, static, final을 생략하더라도 컴파일러가 자동적으로 생성시킨다. 

- 상수명은 대문자로 만들고, 두 단어 이상이 합쳐졌다면 언더바를 사용하자. 


#### 8.2.3 추상 메소드 선언 

- 인터페이스를 통해 호출된 메소드는 최종적으로 객체에서 실행된다. 그렇기 때문에 인터페이스에서 메소드를 선언할 때는 실행 블록이 없는 추상 메소드로 선언한다. .

- 추상 메소드는 리턴 타입, 메소드명, 매개 변수만 기술되고 중괄호{ }를 붙이지 않는다. 

- 인터페이스에 선언된 추상 메소드는 모두 public abstract의 특성을 갖기 때문에 생략하더라도 컴파일러가 자동적으로 생성시킨다. 

#### 8.2.4 디폴트 메소드 선언 

- 디폴트 메소드는 자바 8에서 추가된 인터페이스의 새로운 멤버

- public의 특성을 갖고 있으며, 리턴 타입 앞에 default가 붙는다. 

#### 8.2.5 정적 메소드 선언 

- 기본적으로 public 특징을 갖고 있으며, 리턴 타입 앞에 static이 붙는다. 

- 해당 인터페이스로 구현한 객체들 사이의 전역 메소드이며 오버라이딩이 불가능하다. 그렇기 때문에 구현 클래스에서 다시 작성할 필요 없다. 


### 8.3 인터 페이스 구현 
--- 

- 개발 코드가 인터페이스 메소드를 호출하면 인터페이스에서 객체의 메소드를 호출한다. 객체는 인터페이스에서 정의된 추상 메소드와 동일한 메소드 이름, 매개 타입, 리턴 타입을 가진 실체 메소드를 가지고 있어야 한다. 

#### 8.3.1 구현 클래스 

- 인터페이스 타입으로 사용할 수 있음을 알려주기 위해 클래스 선언부에 implements 키워드를 추가하고 인터페이스 명을 명시해야 한다. 

			public class (구현 클래스명) implements 인터페이스명 { 

					// 인터페이스에 선언된 추상 메소드 실체 메소드 선언 
			}

- 구현 클래스에서 인터페이스의 추상 메소드들에 대한 실체 메소드를 작성할 때 주의 할 점은 인터페이스의 모든 메소드는 기본적으로 public 접근 제한을 갖고 있기 때문에 구현 클래스 속의 메소드도 public 보다 낮은 접근 제한으로 작성할 수 없다. 

- 만약 인터페이스를 implements 한 구현 클래스에서 인터페이스에 있는 추상 메소드의 내용부를 선언하지 않았다면 이 클래스 또한 추상 클래스가 된다. 그래서 클래스 앞에도 abstract를 넣어줘야 한다. 아니면 에러 삐삐 

- 인터페이스의 구현 클래스를 통해 객체 생성하기 

			public class Television implements RemoteControl {

					~~~
			}

			다른 클래스 

			public class RemtoeControlExample {

					public static void main (String[] args) {

							RemoteControl rc ; 		// 먼저 인터페이스 변수를 선언한다. 
							rc = new Television();	// 변수를 이용해 Television으로 객체를 생성 시킨다. 
						
					}
			}

> 그러면 이제 rc 변수를 이용해 인터페이스를 이용한 구현 클래스를 통한 객체를 사용할 수 있다. 

#### 8.3.2 익명 구현 객체 

- 자바는 소스파일을 만들지 않고도 구현 객체를 만들 수 있는 방법을 제공하는데, 그것이 "익명 구현 객체"이다. 

			RemoteControl rc = new RemoteControl() {

					// 인터페이스에 선언된 추상 메소드의 실체 메소드 선언 
			}

#### 8.3.3 다중 인터페이스 구현 클래스 

- 인터페이스 A, B가 객체의 메소드로 호출할 수 있으려면 객체는 이 두 인터페이스를 모두 구현해야 한다. 

			public class (클래스명) implements 인터페이스A,인터페이스B {

					// 인터페이스 A,B가 가지고 있는 모든 추상 메소드 선언해줘야 해 
			}

- 다중 인터페이스로 만들어진 구현 클래스를 객체로 만들 때는 두 인터페이스의 부모 인터페이스를 통해 객체화 시키자 


### 8.4 인터페이스 사용 
---

- 인터페이스로 구현 객체를 사용하러면 인터페이스 변수를 선언하고 구현 객체를 대입해야 한다. 

			(interface) rc = new (구현 클래스)();

> 그리고 rc 변수를 이용해서 구현 클래스의 메소드를 사용할 수 있다. 

#### 8.4.1 추상 메소드 사용 

			RemoteControl rc = new Television();
			
			rc.turnOn();
			rc.turnOff();

> 이런 식으로 추상 메소드를 사용할 수 있다. 

#### 8.4.2 디폴트 메소드 사용 

- 디폴트 메소드는 추상 메소드가 아닌 인스턴스 메소드이므로 구현 객체가 있어야 사용할 수 있다. 

ex) RemoteControl 인터페이스에 setMute(boolean mute) 라는 디폴트 메소드가 있다고 가정하자

	이 상황에서 RemoteControl.setMute(true); 를 사용할 수 없다는 얘기다. 왜냐하면 아직 메소드의 내용부가 정의되어 있지 않기 때문이다. 

- 디폴트 메소드는 인터페이스의 모둔 구현 객체가 가지고 있는 기본 메소드라고 생각하면 된다. 

- 구현 클래스를 작성하 ㄹ때 디폴트 메소드를 오버라이딩해서 자신에게 맞게 수정하면 디폴트 메소드를 자신이 원하는 대로 사용할 수 있다. 


#### 8.4.3 정적 메소드 사용 

- 정적 메소드는 인터페이스로 바로 호출이 가능하다. 

			RemoteControl.setMute(true);

> 위 명령이 가능하다는 것이다. 

### 8.5 타입 변환과 다형성 
---

- 요즘은 상속보다는 인터페이스를 통해서 다형성을 구현하는 경우가 더 많다. 

- 다형성은 하나의 타입에 대입되는 객체에 따라서 실행 결과가 다양한 형태로 나오는 성질을 말한다. 

- 인터페이스는 어떤 구현 객체를 대입하느냐에 따라 실행 결과가 달라진다. 상속은 같은 종류의 하위 클래스를 만드는 기술이고, 인터페이스는 사용 방법이 동일한 클래스를 만드는 기술이라는 개념적 차이는 있지만 둘 다 다형성을 구현하는 기술이다. 

- 인터페이스는 메소드의 매개 변수로 많이 등장한다. 인터페이스 타입으로 매개 변수를 선언하면 메소드 호출 시 매개값으로 여러 각지 종류의 구현 객체를 줄 수 있기 때문에 메소드 실행 결과가 다양하게 나온다. 

#### 8.5.1 자동 타입 변환 

- 구현 객체가 인터페이스 타입으로 변화되는 것은 자동 타입 변환에 해당된다. 

			(인터페이스) 변수 = 구현객체;

- 인터페이스 구현 클래스를 상속해서 자식 클래스를 만들었다면 자식 객체 역시 이넡페이스 타입으로 자동 타입 변환시킬 수 있다. 

- 자동 타입 변환을 이용하면 필드의 다형성과 매개 변수의 다형성을 구현할 수 있다. 

#### 8.5.2 필드의 다형성 

- 상속 
	- Tire -> 부모 클래스 , GumhoTire -> 자식 클래스 

- 인터페이스 
	- Tire -> 인터페이스 , GumhoTire -> 구현 클래스 



#### 8.5.3 인터페이스 배열로 구현 객체 관리 

- 인터페이스도 배열을 이용하여 관리할 수 있다. 

			Tire[] tires = {

					new HankookTire();
					new HankookTire();
					new HankookTire();
					new HankookTire();
			}

> 결국 배열이라 하여도구조를 보면 Tire tires = new HankookTire(); Tire은 인터페이스 배열 자료형이 된 것이고, tires는 인터페이스 변수이고 = 이후는 같은 객체 형성으로 보면 된다. 


#### 8.5.4 매개 변수의 다형성 

- 자동 타입 변환은 필드의 값을 대입할 때에도 발생하지만, 주로 메소드를 호출할 때 많이 발생한다.
	- 상속 : 매개 변수를 부모 타입으로 선언하고 호출할 때에는 자식 객체를 대입한다. 
	- 인터페이스 : 매개 변수를 인터페이스 타입으로 선언하고 호출 할 때에는 구현 클래스를 대입한다. 

- 매개 변수의 타입이 인터페이스일 경우, 어떠한 구현 객체도 매개값으로 사용할 수 있고, 어떤 구현 객체가 제공되느냐에 따라 메소드의 실행 결과는 다양해질 수 있다. 


#### 8.5.5 강제 타입 변환

- 구현 객체가 인터페이스 타입으로 자동 변환되면, 인터페이스에 선언된 메소드만 사용 가능하다는 제약 사항이 따른다. 
	ex) 인터페이스에 추상 메소드 3개 , 구현 클래스에 메소드가 5개인 상황에서 구현 클래스가 인터페이스 타입으로 자동 변환 되었다면 인터페이스에 선언된 3개의 메소드만 사용가능하다. 

#### 8.5.6 객체 타입 확인 (instanceof)

- 메소드의 매개 변수가 인터페이스로 선언된 경우, 메소드를 호출할 때 다양한 구현 객체들ㅇ르 매개값으로 지정할 수 있다. 

- 그렇기 때문에 매개변수를 넣고 instanceof를 통해 형변환이 가능한지 확인 후 메소드를 사용하게 하는 것이다. 


### 8.6 인터페이스 상속
---

- 인터페이스도 다른 인터페이스를 상속할 수 있다. 또한 다중 상속을 허용한다. 

			public interface (하위인터페이스) extends (상위인터페이스1),(상위인터페이스2)

- 하위 인터페이스를 구현하는 클래스는 하위 인터페이스의 메소드 뿐만아니라 상위 인터페이스의 모든 추상메소드에 대한 실체 메소드를 가지고 있어야 한다. 


### 8.7 디폴트 메소드와 인터페이스 확장
---

- 디폴트 메소드는 인터페이스에 선언된 인스턴스 메소드이기 때문에 구현 객체가 있어야 사용할 수 있다. 


#### 8.7.1 디폴트 메소드의 필요성 

- 디폴트 메소드는 추상 메소드가 아니기 때문에 구현 클래스에서 실체 메소드를 작성할 필요가 없다. 

- 그렇기 때문에 이후 인터페이스에 새로운 메소드를 넣으려고 할 때, 구현 클래스에서 추상 메소드를 구현하지 않으면 에러가 생기는 문제점이 있었다. 그것을 해결하기 위하여 디폴트 메소드를 사용하는 것이다. 

- 디폴트 메소드는 인터페이스에서도 내용부를 작성할 수 있다. 정적 메소드와 마찬가지로...

#### 8.7.2 디폴트 메소드가 있는 인터페이스 상속 

- 상위 인터페이스에 디폴트 메소드가 있는 경우 하위 인터페이스에서 상위 디폴트 메소드를 사용할 수 있는 3가지 방법이 있다. 
	1. 디폴트 메소드를 단순히 상속만 받는다. (하위 인터페이스에서 다시 선언 x)
	2. 디폴트 메소드를 override해서 실행 내용을 변경한다. 
	3. 디폴트 메소드를 추상 메소드로 재선언 한다. (하위 인터페이스에서) 









