# Modifier



## 1. 접근 제한자  (Access Modifier)

---

* java 접근 제한자에는 **public**, **protected**, **default**, **private** 이 있다. 

### 1.1 접근 제한자 별 접근 허용 범위 

| 접근 제한자 | 허용범위                                |
| ----------- | --------------------------------------- |
| public      | 모든 접근을 허용                        |
| protected   | 동일 패키지와 하위 클래스에게 접근 허용 |
| default     | 동일 패키지에서 접근 허용               |
| private     | 현재 객체 내에서만 허용                 |

* 현재 흐름 

default라고 언급하는 것 보다 **package-private**라고 하는 것이 조금 더 잘 설명하고 있다. 

* package-private

자바의 경우, package-private한 클래스를 package **외부의 클래스에서 package 이름을 그대로 사용하면** 해당 클래스를 사용할 수 있기 때문에 사실상 **정보 은닉**을 할 수 없다.

*  protected

자바의 경우, protected 접근 제한자가 붙은 필드, 메소드는 같은 패키지라면 모든 클래스가 사용가능하고, 외부 패키지라면 상속한 자식 클래스만이 사용가능하다. 

> 하지만 다른 언어는 같은 패키지에서는 사용이 불가능하고 상속받은 클래스만이 사용가능하도록 설계되어 있다. 

```java
package io.thethelab.hello;

class User{
	protected int age;
}

class Program {
//Program 클래스는 내부패키지에 있는 클래스로 User클래스의
// protected한 필드를 사용할 수 있다. 

	public static void main(String[] args){
    User user = new User();
    user.age = 100;
	}
}
```

> 이런 식으로 같은 패키지명으로 의도적으로 바꾸면 접근 제한자의 핵심적인 정보 은닉이 불가능해지는 문제가 발생된다. 



## 2. 다양한 Modifier

---

### 2.1 final

* 불변 객체를 의미한다. final로 선언된 객체는 초기화 및 할당을 최초 1회만 수행할 수 있다. 변수에 사용했다면 변하지 않는 상수값이 되는 것이다. 

### 2.2 static

* 인스턴스에 속한게 아닌, 클래스에 속해있는 변수로 여러 클래스가 공유하는 변수를 의미한다. 클래스가 인스턴스화 되기 전 클래스 로딩시점에 이미 생성되고 단 하나의 객체가 공유되는 개념으로 사용된다. 

### 2.3 abstract

* 추상 메소드, 추상 인터페이스를 정의하는 키워드로 abstract method의 경우 하위 클래스에서 반드시 abstract를 구현해야 한다. 

### 2.4 synchrornized

* 스레드 동기화를 위해서 사용되는 키워드로 synchronized로 선언된 메소드는 어떤 쓰레드가 대상 메소드를 실행중일 때 다른ㄹ 메소드가 접근을 못하도록 한다. 메소드나 객체에 synchronized 키워드를 선언할 수 있다. 

### 2.5 strictfp

* 자바에서 float이나 double형은 비트 연산의 정밀도가 달라서 부동소수점 연산시 소수점 연산의 에러 가능성이 항상 존재한다. strictfp 키워드를 클래스나 메소드에 지정하는 경우 부동소수점 숫자의 정밀도를 보장한다. 

### 2.6 native

* Interface를 설계할 때 내부 메소드에 사용되는 키워드이다. native는 자바가 아닌 다른 언어로 구현할 것이라고 알려주는 키워드이다. JNI를 이용하여 이기종간 호환을 위해서 사용되는 키워드이다. 

### 2.7 transient

* Serialize의 반대개념으로 대상 변수는 직렬화/역직렬화 처리시 제외한다는 키워드이다.  키워드가 지정된 변수는 직렬화를 통한 오브젝트 통신시에 제외되고 처리된다. 

### 2.8 volatile

* 멀티쓰레드 환경일 경우 각 쓰레드마다 동일 메모리를 공유하는 것이 아닌 별도 메모리 공간(cpu캐시)에서 변수를 읽어온다. 이런 경우 각 쓰레드마다 동일한 변수의 값을 다르게 기억할 수 있다.  volatile 키워드는 변수를 읽어 들일 때 cpu캐시가 아닌 컴퓨터 메인 메모리로부터 읽거나 쓰도록 처리한다. volatile은 하나의 쓰레드에서만 쓰기작업을 하고, 다른 쓰레드는 읽기 작업만 하는 경우 효율적으로 사용할 수 있다. 

> 2.5, 2.6, 2.7, 2.8 부분은 나중에 나오면 다시 공부하는 것으로 하자. 현재는 정확히 무엇을 의도하고 만들어진 것인지 알기가 어렵다. 아직 알아야 할 것들이 산더미인데 이런것에 미련갖지 말자. 



