# DataType



## 1. Primitive Typee

---

* ### Privitive Type의 종류

| 종류 | 타입    | 크기  |
| ---- | ------- | ----- |
| 정수 | byte    | 1byte |
|      | char    | 2byte |
|      | short   | 2byte |
|      | int     | 4byte |
|      | long    | 8byte |
| 실수 | float   | 4byte |
|      | double  | 8byte |
| 논리 | boolean | 1bit  |

* ### 특징

  - 자바에서 기본 자료형은 반드시 사용하기 전에 선언되어야 한다. 

  - Type마다 size가 고정되어 있다. 

  - 비객체 타입, 기본 값을 가지고 있으므로 null값을 가질 수 없다. 

  - stack영역에서 생성되고 사라진다. 

  - generic을 이용하기 위하여 필요한 wraper class가 존재한다. 

    (Integer, Long .. 등등)

  - 컴파일 시, 크기를 초과하면 에러가 발생한다. 

  



## 2. Reference Type

---

* ### Reference Type의 종류 

배열(Array), 열거(Enum), 클래스(Class), 인터페이스(Interface)



* ### 특징

  * 기본형을 제외한 모든 타입은 Reference Type이다. 
  * java.lang.Object를 상속 받는다. 
  * Heap영역에 저장된다. 
  * 기본 값은 아무런 참조 정보가 없으므로, null을 리턴한다. 



## 3. equals와 ==의 차이점

---

* ### equals :

  * 기본적으로 Object의 상속을 받는 클래스의 메소드이다. 
  * 대상의 내용 자체를 비교 합니다. (call by value)
  * 예를들어 int, float, double 등 primitive type들을 비교하는데에 사용된다. 

* ### == :

  * 대상의 주소값을 비교한다. (call by reference)
  * 예를들어 reference type들을 비교하는데 사용된다. 



## 4. 상수(Constant)와 리터럴(LIteral)

---

### 4.1 공통점

* 상수, 리터럴 모두 변하지 않는 값(데이터)를 말한다. 

### 4.2 상수

* 상수는 변하지 않는 **변수**를 의미한다. 
* 상수는 변수이지 꼭 숫자만 대입되어야 하는 것은 아니다. 
* 클래스를 final로 상수화 했을 때 참조변수가 상수인 것이지 그 주소가 가리키는 데이터들까지 상수라는 의미는 아니다. 

```java
final Test t1 = new Test();
t1 = new Test();
```

> 이런 방식으로 상수화된 클래스를 객체로 생성한 후에 새로운 객체를 생성하려고 할 때는 에러가 발생한다. Test t1 객체 자체가 상수화 되었기 때문이다. 

### 하지만

```java
final Test t1 = new Test();
t1.num = 10;
```

> 위와 같이 객체 내에 존재하는 데이터는 변경되어도 상관 없다. 

### 4.3 리터럴

* 리터럴은 데이터 그 자체를 뜻한다. ( 변수에 넣는 변하지 않는 데이터를 의미하는 것이다. )

```java
final int a = 1;
```

> 위 처럼 int 앞에 final을 붙일 시 a는 상수가 된다. 여기서 리터럴은 '1'을 의미한다. 

즉 1과 같이 변하지 않는 데이터 (boolean, char, int, double, float 등등)를 리터럴 이라고 부른다. 

* (의문?) 인스턴스(클래스를 구현한 객체)가 리터럴이 될 수 있을까? 

정답은 그렇지 않다. 만약 인스턴스안에 있는 값들을 변경하지 않는다면 모를까... 보통의 인스턴스는 동적으로 사용하기 위해 작성되므로, 리터럴이 될 수 없다. 왜냐하면 값이 언제 바뀔지 모르기 때문이다. 

```java
String test = "hello";			// 리터럴 방식의 선언이다. 

String test = new String();		// 객체 생성을 통한 선언이다. 
```

> String은 java에서 리터럴 방식으로 선언할 수 있도록 지원하고 있다. 클래스임에도 불구하고 특수한 예라고 생각하면 될 것 같다. 
>
> 생각해볼 것은 객체 생성의 방식과 리터럴 선언 방식에 차이가 있다는 점 

* 객체에도 리터럴이라는 표현이 사용될 수 있다. 

데이터가 변하지 않도록 설계를 한 클래스를 불변 클래스라고 칭한다. 해당 클래스는 한 번 생성하면 객체 안의 데이터가 변하지 않는다. 변할 상황이 생기면 새로운 객체를 만들어준다. (ex. String, Color와 같은 불변 클래스)

### 4.4 정리 

정리하자면, **상수는 변하지 않는 변수**(메모리 위치)를 의미하며 메모리 값을 변경할 수 없다. 

리터럴은 **변수의 값이 변하지 않는 데이터**(메모리 위치 안의 값)를 의미한다.  