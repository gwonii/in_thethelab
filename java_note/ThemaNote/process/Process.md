# Process

### 1. Concurrent-Programing and Parallel-Programing

------

## 1.1 병행과 병렬의 차이 

- 소프트웨어에서는 병렬 프로그래밍과 병행 프로그래밍을 구분한다.

1. 병행 프로그래밍 (Concurrent Programing) 
   - 컴퓨터가 하나의 코어에서 마치 여러 일을 동시에 수행하듯이 보여주는 프로그래밍
   - 하나의 작업을 작은 단위로 나누어 분할하여 처리
2. 병렬 프로그래밍 (Parallel Programing) 
   - 컴퓨터가 여러 개의 코어로 여러 작업들을 동시에 수행하는 프로그래밍
   - 여러 작업들을 동시에 처리

#### 결국 멀티 프로세스의 유무에 따라 병행과 병렬을 구분할 수 있다. 병행 프로그래밍내에 병렬 프로그래밍으로 설계될 수 있다. 

## 1.2 Process와 Thread의 차이 

1. 프로세스는 환경을 관장하고, 쓰레드는 실행을 관장한다. 

2. 각각의 프로세스는 각각의 독립된 메모리를 가지고 있다. 그렇기 때문에 프로세스는 서로 독립적이다. (ex. 하나의 프로세스가 오류가 난다고 다른 프로세스에 영향을 주지 않는다.)

   각각의 쓰레드는 한 프로세스의 환경을 공유한다. 그렇기 때문에 프로세스내에 쓰레드는 서로에게 영향을 끼칠 수 있다. 

3. 프로세스는 독립적이기 때문에 안정성이 높다. 반대로 쓰레드는 독립적이지 않기 때문에 안정성을 확보하기 어렵다. (그러므로 쓰레드는 잘 컨트롤해주어야 한다.)

4. 멀티 프로세스는 system call에 의해 만들어지고, 멀티 쓰레드는 thread API에 의해 만들어 진다. (ex. c언어 : pthread API 다른 언어는 만드는 방식이 다르다.)

   

### 2. Process

------

## 2.1 Process 개요 

- thread와 달리 system call로 프로세스를 생성한다. 
- 프로세스는 자원을 관장한다. 
- 프로세스는 독립적이다.
- 프로세스는 안정성이 높다.
- 프로세스가 종료하는 것은 프로세스내에 모든 쓰레드가 종료하는 것을 의미한다. 
- 메인 함수의 반환이 프로세스의 종료를 의미하는 것 (메인 함수의 반환과 메인 쓰레드의 반환을 헷갈리지 말 것)
  - 메인 쓰레드가 반환되어도 프로세스는 종료하지 않는다. 모든 쓰레드가 종료되어야 프로세스가 종료되기 때문이다. 

## 2.2 Process 생성과정

- 기본적으로 (c 언어에서) ./a.out 의 실행파일을 만들게 되면 프로세스를 만들고 그 안에 기본 쓰레드가 생성된다. (여기서 기본 쓰레드는 메인 쓰레드를 의미한다. )
- system call 의 함수들 
  - fork() : 새로운 프로세스를 생성할 때 사용된다. 
  - wait() : 자식 프로세스가 끝날 때 까지 기다릴 때 사용된다. 
  - getpid() : 현재 프로세스의 id를 가져온다. 
  - getppid() : 부모 프로세스의 id(parent pid) 를 가져온다. 

1. #### fork()를 통한 프로세스 생성 

   - fork는 반환 값을 통해 부모 프로세스와 자식 프로세스로 분리된다. 
   - fork()를 실행한 후 부터는 멀티 프로세스로 각각 실행되기 시작한다. 

- 부모 프로세스는 0 이상의 값, 자식 프로세스는 0의 값을 갖는다. 
  - 실패시 -1 값을 전달함 

### process1.c

```c
#include <stdio.h>
#include <stsdlib.h>
#include <unistd.h>						// fork() 함수를 담고 있는 헤더파일
#include <sys/wait.h>


int main () {
  int i;
  pid_t pid;
  
  pid = fork();							// fork() 함수를 호출하는 순간 자식 프로세스, 부모 프로세스											의 분기가 시작되서 하위의 내용을 각각 실행한다. 
  if(pid > 0) {
    int status;
    wait(&status);						// 자식 프로세스의 종료 상태를 얻기 위하여 사용됨 
    printf("status: %d \n", status);	  // 다시 말하면 자식 프로세스가 종료 될 때 까지 기다린다. 
    
      for(i = 0; i < 3; ++i){
        printf("parent process...\n");
        sleep(1);
      }
      exit(0);
  } else if (pid == 0){
      for(i = 0; i < 5; ++i){
        printf("child process...\n");
        sleep(1);
      }
      exit(0);
  } else {
      perror("fork");
      exit(0);
  }
  
  printf("hello.....\n");
  
    
}

```

- fork() 함수가 실행 된 직후에는 자식 프로세스와 부모 프로세스가 동일한 주소 공간의 복사본을 가지게 된다. 
- 분기가 시작되었을  경우 자식 프로세스가 먼저 실행될 지, 부모 프로세스가 먼저 실행될 지는 알 수 없다.  하지만 wait() 함수를 사용할 경우, 자식 프로세스가 끝날 때 까지 부모 프로세스는 기다린다. 

### 문제점 

- wait()의 사용으로 인하여 멀티프로세스의 장점인 동시성이 훼손된다. 

  기본적으로 **wait()**은 자식 프로세스의 종료 시점을 알기 위하여 사용된다. 종료 시점을 보내지 않으면 자식 프로세스는 실행을 완료했음에도 불구하고 부모 프로세스가 작동하는 도중에 데이터가 계속 남아있다. 이것을 **좀비 프로세스**라고 한다. 그런데 좀비 프로세스는 메모리의 낭비를 유발하고 cpu에 안좋은 영향을 끼친다. 그러므로 wait을 통해 자식 프로세스의 종료 시점을 받아야 하는 것이다. 

  그런데 여기서 문제는 **wait()** 을 사용하면 자식 프로세스가 종료될 때 까지 부모 클래스는 실행을 하지 않는다. 그런데 멀티프로세스는 병행성의 장점을 갖고 있는 것인데 **wait()** 때문에 동시성이 훼손된 것이다. 

> 좀비 프로세스 확인 하는 법 : ps -ef | grep defunct | grep -v grep 명령어를 통해서 <defunct> 를 찾을 수 있다. 



### 해결책

- signal을 이용하여, 자식의 종료 시점을 부모 프로세스에게 전달한다. 

  우리가 의도하는 것은 부모 프로세스와 자식 프로세스가 동시에 작동하고, 자식 프로세스가 종료되는 시점에 부모 프로세스에게 종료시점을 전달하여 좀비 프로세스를 차단하는 것이다. 

  이런 결과를 얻기 위해서 사용할 수 있는 것은 **signal** 이다. signal은 system call을 통해 신호를 보낼 수 있다. 그러면 우리는 자식 프로세스가 종료될 때, 자식 프로세스가 종료되었다는 signal을 보내고 wait()을 사용하면 된다. 

### process2.c

```c
#include <unistd.h>
#include <sys/wait.h>
#include <stdio.h>
#include <stdlib.h>

// 자식 프로세스는 자신이 종료될 때, 부모 프로세스에게 SIGCHLD 시그널을 전달한다.
void foo(int signum) {
	printf("자식 죽음...\n");
	int status;
	wait(&status);
	printf("status: %d\n", status);

}

int main() {
    // SIGCHLD는 자식 프로세스의 변화가 생길 때, 신호를 보내라는 의미를 가지고 있다. 
	signal(SIGCHLD, foo);				
	int i;
	pid_t pid;

	pid = fork();
	if (pid > 0) {  // 부모 프로세스
		for (i = 0; i < 30; ++i) {
			printf("parent process..\n");
			sleep(1);
		}
		exit(0);

	} else if (pid == 0) { // 자식 프로세스
		for (i = 0; i < 3; ++i) {
			printf("child process..\n");
			// 의도적인 pid값의 변화는 허용하지 않는다. (안된다. 영향을 못끼친다.)
             pid = -28; 		
             sleep(2);
		}
		exit(0);

	} else {
		perror("fork");
		exit(1);
	}
	// fork()가 반환될 때, 자식 프로세스도 fork() 함수를 반환한다.
	printf("hello, world...\n");
}
```

- 위에서 언급했던 것 처럼 foo 라는 함수를 만들어, signal(SIGCHLD, foo) 를 사용한다. 이 함수를 사용하면 자식 프로세스의 변화(여기서는 종료)가 생길 때 foo라는 함수를 호출하라고 signal을 보내고 있는 것이다. 
- 결과적으로 두 프로세스가 동시에 진행되고, 부모 프로세스가 종료되면 프로그램이 종료된다. 

## 2.3 wait()함수의 주의사항

- wait() 함수는 기본적으로 블럭 함수기 때문에 동시성이 떨어진다. 그렇기 때문에 비동기식으로 사용하는데 있어서 주의를 해야 한다. (무조건 적으로 블럭/비동기를 사용할 수 없는 것은 아님 하단에 블럭 참조)
- 프로세스를 만드는 것은 누구나 할 수 있으나 그 각각의 프로세스를 통제할 줄 알아야 한다. 

## 2.4 SIGNAL

#### 2.4.1 시그널 이란? 

- 시그널이란, software interrupt로, process에 무엇인가 발생했음을 알리는 간단한 메시지를 비동기적으로 보내는 것이다. 
- 시그널을 받은 프로세스는 시그널에 따른 동작을 수행한다. 

#### 2.4.2 시그널의 종류

- 시그널은 <signal.h> 헤더파일에 정의도어 있고 시그널에 따른 기본 처리는 프로세스를 종료하거나, 코어 덤프를 생성한다. 

> 코어 덤프란, 특정 시점에 코어 파일을 만들고 종료한다. 코어 파일이란, 비정상적으로 프로세스가 종료되는 경우 프로세스의 영역을 코어 파일이라는 이름으로 프로그램을 실행 위치에 저장하는 파일을 말한다. 

| 함수    | 헤더파일                  | 함수 원형                                                    | 설명                                                         |
| ------- | ------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| kill    | <sys/types.h>, <signal.h> | int kill(pid_t pid, int sig)<br />pid : 시그널을 받을 프로세스 id<br />sig : pid로 지정된 프로세스에 보내려는 시그널 | pid > 0 인 경우, pid로 지정한 프로세스에게 시그널을 보낸다.  |
| raise   | <signal.h>                | int raise(int sig)<br <br />sig : 보내려는 시그널            | 함수를 호출한 프로세스에게 인자로 지정한 시그널을 보낸다. <br />signal handler가 호출되면 signal handler의 수행이 끝날 때 까지 raise 함수는 리턴하지 않는다. |
| abort   | <sidlib.h>                | void abort(void)                                             | 이 함수를 호출한 프로세스에 SIGABRT 시그널을 보낸다. <br />SIGABRT 시그널은 프로세스를 비정상적으로 종료시키고 덤프 파일을 생성한다. |
| sigsend | <signal.h>                | int sigsend(idtype_t, idtype, id_t, int sig)                 | sig로 지정한 시그널을 id로 지정한 프로세스나 프로세스 그룹에 보낸다. |

#### 2.4.3 다양한 시그널 

![](C:\Users\hoho\Desktop\캡처1.PNG)

#### 2.4.4 시그널의 특징

- 시그널이 동시에 발생하면, 하나만 처리된다. 
- 시그널 핸들러 안에서는 절대 블록되는 함수를 호출하면 안된다. ( 시그널 핸들러안에서 블록되면, 시그널 핸들러를 호출한 프로세스가 대기하게 된다. )

## 2.5 시그널의 문제점

- 시그널은 기본적으로 동시에 사용될 수 없다. 동시에 시그널이 발생하면, 그 중 하나의 시그널만 처리된다. 

  이 말은 결국 여러 프로세스가 작동하더라도 시그널은 동시다발적으로 사용되지 않는다는 것을 의미한다. 

#### process3.c

```c
void foo(int signum) {
	int status;
	while (wait(&status) > 0) {
		printf("status: %d\n", status);
	}
}

int main() {
	signal(SIGCHLD, foo);
	int i;
	pid_t pid;

	for (int j = 0 ; j < 10; ++j) {
		pid =	fork();
		if (pid == 0) { 
			for (i = 0; i < 3; ++i) {
				printf("child process..\n");
				if (j > 5) {
					sleep(1);
				}
			}
			exit(0);
		} 
	}
	for (i = 0; i < 30; ++i) {
		printf("parent process..\n");
		sleep(1);
	}
	exit(0);
}
```

- 동시 다발적인 signal로 인해 문제가 발생했다.

  위 코드의 문제점은 여러 자식 프로세스들이 실행이 종료되고 signal을 보내어 foo함수를 호출하게 만들었다. 그런데 동시 다발적으로 signal을 보내게 되어 총 프로세스의 생성횟수와 foo를 호출한 횟수가 서로 다르다. 

### 해결책

#### process4.c

```c
void foo(int signum) {
	int status;
	while (waitpid(0, &status, WNOHANG) > 0) {
		printf("status: %d\n", status);
	}
}
```

- 이 문제를 해결하기 위하여 wait()함수가 아닌 waitpid() 함수를 사용하였다. 
- waitpid() 함수는 자식 프로세스가 종료될 때 까지 차단되는 것을 원하지 않을 경우, 옵션을 사용하여 차단을 방지할 수 있다. 

#### 2.5.1 waitpid 함수 

```c
#includ <sys/wait.h>
pid_t waitpid(pid_t pid, int *staloc, int options);

성공: 프로세스 ID 반환 
오류: -1
```

#### 첫번째 인자 

| waitpid 함수의 첫번 째 인자 | 의미                                                         |
| --------------------------- | ------------------------------------------------------------ |
| (pid == -1) 일 경우         | 임시의 자식 프로세스를 기다림                                |
| (pid > 0) 일 경우           | 프로세스 ID가 pid인 자식 프로세스를 기다림                   |
| (pid < -1) 일 경우          | 프로세스 그룹 ID가 pid의 절댓값과 같은 자식 프로세스를 기다림 |
| (pid == 0) 일 경우          | waitpid를 호출한 프로세스의 프로세스 그룹 PID와 같은 프로세스 그룹 ID를 가진 프로세스를 기다림 |

#### 두번째 인자 

|                                   | waitpid 함수 반환 값 | 의미                                                         |
| --------------------------------- | -------------------- | ------------------------------------------------------------ |
| 자식 프로세스가 정상적으로 종료   | 프로세스 ID          | \- WIFEXITED(statloc) 매크로가 true를 반환<br />\- 하위 8비트를 참조하여 자식 프로세스가 exit, _exit, _Exit에 넘겨준 인자값을 얻을 수 있음, WEXITSTATUS(statloc) |
| 자식 프로세스가 비정상적으로 종료 | 프로세스 ID          | - WIFSIGNALED(statloc) 매크로가 true를 반환<br />- 비정상 종료 이유를 WTERMSIG(statloc) 매크로를 사용하여 구할 수 있음 |
| waitpid 함수 오류                 | -1                   | - ECHILD : 호출자의 자식 프로세스가 없는 경우<br />- EINTR : 시스템 콜이 인터럽트 되었을 때 |

#### 세번째 인자

| option 종류 | 의미                                                         |
| ----------- | ------------------------------------------------------------ |
| WCONTINUED  | 중단 되었다가 재개된 자식 프로세스의 상태를 받음             |
| WNOHANG     | 기다리는 PID가 종료되지 않아서 즉시 종료 상태를 회수할 수 없는 상황에서 호출자는 차단되지 않고 반환 값으로 0을 받음 (위에서 사용된 option) |
| WUNTRACED   | 중단된 자식 프로세스의 상태를 받음                           |

