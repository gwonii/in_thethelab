# 5. Scheudling

------

#### 스케쥴링을 공부하기 전 참고사항 

```
스레드를 지원하는 운영체제에서는 프로세스가 아니라 커널 수준의 스레드를 스케줄링 한다. 그러나 프로세스 스케줄링과 스레드 스케줄링 용어는 상호 교환적으로 사용 되며 일반적인 스케줄링을 논의하는 경우에는 프로세스 스케줄링을 사용하고 스레드에 국한된 개념을 가리키는 경우에 스레드 스케줄링이라는 용어를 사용한다.
```

- 스레드의 개수가 코어의 수 보다 많을 경우, 스레드를 어떤 순서에 의해 동시성을 실행할 것인지 결정해야 한다. 

## 5.1 선점형 스케줄러와 비 선점형 스케줄러

### 5.1.1 비 선점형 스케줄러

- 협력형 (비선점형) 스레드 스케쥴링은 실행 중인 스레드가 cpu 사용권을 다른 스레드에게 넘길 때 까지 기다리는 방식이다. 

- 이미 할당된 cpu를 다른 프로세스가 강제로 빼앗아 사용할 수 없는 스케쥴링 기법이다. 

  

### 장점 

- 선점형 방식보다 스케줄러 호출 빈도가 낮고, 문맥 교환에 의한 오버헤드도 적다. 
- 일괄처리 시스템에 적합하다. 

### 단점

- 속도면에서 선점형 방식보다 떨어질 수 있다. 
  - cpu 사용 시간이 긴 하나의 프로세스가 cpu 사용 시간이 짧은 여러 프로세스들을 오랫동안 대기시킬 수 있는 상황이면, 전체 프로그램의 속도가 떨어지는 것이다. 

### 5.1.2 선점형 스케줄러 

- 선점형 스레드 스케쥴링 방식은 프로세스의 우선권을 가지고 우선순위가 높은 프로세스를 먼저 수행시키는 방식이다. 
- 하나의 프로세스가 cpu를 할당 받아 실행하고 있을 때 우선순위가 높은 다른 프로세스가 cpu를 강제로 빼앗아 사용할 수 있다. 
- (실행->대기) , (대기->준비), (수행->종료)의 단계가 반복적으로 일어난다. 

### 장점

- 모든 프로세스에게 cpu 사용 시간을 동일하게 부여할 수 있다. 
- 빠른 응답시간을 요하는 대화식 시분할 시스템에 적합하다. 
- 긴급한 프로세스의 우선순위를 제어하여 필요한 것부터 실행시킬 수 있다. 

### 단점 

- 비선점형 방식보다 스케줄러 호출 빈도가, 잦은 문맥교환으로 인한 오버헤드가 발생 할 수 있다. 

> <https://codedragon.tistory.com/5346>

## 5.2 Round Robin Scheduling (RR)

- 선점형 스케쥴러 방식이다. 
- 라운드로빈 스케쥴 방식은 시분할 시스템을 위해 설계된 선점형 스케쥴링 방식이다. 
- 프로세스들 사이에 우선순위를 두지 않고, 순서대로 시간단위로 cpu를 할당하는 방식의 알고리즘
- 기본적으로 연결리스트를 통해 구현되어 있다. 
- 라운드로빈은 모두에게 공평한 알고리즘이다. 

#### 5.1.1 문맥교환 

- 라운드로비는 기본적으로 timeslice를 정해놓고 프로세스에게 일을 시킨다. 
- 간단히 원형큐를 빙빙 돌며 각각이 맡은 일을 정해진 시간만큼 한다고 생각하면 된다.
- 모두에게 같은 timeslice를 제공하기 때문에 실행 시간이 긴 프로세스의 경우 문맥교환이 일어날 수 있다. 

![캡처](C:\Users\hoho\Desktop\캡처.PNG)

위의 예시를 보면 timeslice는 4ms이다. 그런데 p1의 경우 8ms의 시간이 필요하다. 그러므로 cpu는 처음에 p1에게 4ms의 시간을 주고 다음 p2로 넘어가게 설계되어 있다. 이 p1과 p2를 넘어가는 과정에서 **문맥교환**이 발생한다. 그러므로 적절하게 timeslice를 결정하는 것이 중요하다. 그렇지 않고, timeslice가 너무 짧아 **문맥교환**이 너무 많이 발생하면 문맥교환에 너무 많은 시간을 사용한다. 반대로 timeslice가 너무 길어 문맥교환의 횟수가 너무 없어지면 단일 프로세스와 크게 달라지지 않아 전체적인 시스템 속도에 악영향을 준다. 

> <https://haun25ne.tistory.com/54>

### 문제점

- 속도 면에서 이후에 나올 스케줄링 방식보다 뒤쳐진다.
  - 라운드로빈 방식의 경우 단순히 연결리스트를 이용하여 우선순위가 높은 프로세스에 대해서 차례로 실행권한을 준다. 이런 방식으로 모든 리스트들을 반복적으로 다 돌면서 실행권한을 주다보니 속도면에서 많이 떨어지게 된 것이다. 

## 

## 5.3 O(1) 스케줄러

- 기존 스케줄러 방식에서 -19 ~ 20 의 nice 값을 도입하여 프로세스의 우선순위를 구분하였다. 
- 기존의 연결리스트 방식이 아닌, 해쉬맵 방식을 통하여 우선순위가 높은 프로세스에게 쉽게 실행권을 제공해 줄 수 있다. 

### 문제점

- nice값이 적절한 timeslice를 제공하지 못한다는 점에서 문제가 발생하였다. 

#### ex) 

nice 값이 0과 1을 가진 두 개의 프로세스가 실행 된다고 가정 하자. nice 0의 timeslice는 100ms이고 nice 1의 timeslice는 95ms이다. 그리고 nice 값이 18과 19인 두 개의 프로세스가 있다고 가정해보자. nice 18은 timeslice가 10ms이고 nice 19는 5ms이다. 이렇게 nice값을 이용하여 비율에 따라 우선순위를 제공했지만 같은 nice값의 1차이가 0과 1 그리고 18과 19사이에 차이가 생기면서 문제가 생겼다. 같은 nice값의 차이 임에도 불구하고 nice 18과 19는 timeslice가 두 배의 차이를 보이고 있다. 이런 비율의 문제로 인하여 starving 문제가 생기면서 프로그램이 자주 죽는 문제가 생겼다. 

## 5.4 CFS 스케줄러 

- CFS 스케줄러는 O(1) 스케줄러와 달리 모든 태스크에 같은 timeslice를 제공한다. 
- CFS 스케줄러는 nice 값을 절대적인 timeslice와 분리하였다. 
- 그리하여 같은 timeslice를 모든 태스크들이 부여받지만, 태스크들마다 timeslice안에서의 흐르는 시간을 다르게 만들어 모든 우선순위에 따라 태스크를 진행하되, 우선순위가 낮은 태스크도 자신이 할당 받은 timeslice 동안 실행될 수 있도록 하였다. (그리하여 straving 문제를 해결하였다. )

